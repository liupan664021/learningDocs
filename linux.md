## Linux学习笔记

[toc]



### 1. Shell的使用

shell 就是一个程序，它接受从键盘输入的命令， 然后把命令传递给操作系统去执行。

当使用图形用户界面时，我们需要另一个和 shell 交互的叫做终端仿真器的程序。这个终端程序被简单的称为"terminal"，但是存在着不同的终端程序。

```shell
[me@linuxbox ~]$
```

用户名@主机名，紧接着当前工作目录和一个美元符号。

如果提示符的最后一个字符是“#”, 而不是“$”, 那么这个终端会话就有超级用户权限。

##### 复制和粘贴

按下鼠标左键，沿着文本拖动鼠标（或者双击一个单词）高亮了一些文本， 那么这些高亮的文本就被拷贝到了一个由 X 管理的缓冲区里面。然后按下**鼠标中键**， 这些文本就被粘贴到光标所在的位置。

##### 简单的命令

- date
- cal
- df
- free
- exit

### 2. 文件系统中跳转

| 快捷键        | 运行结果                                                     |
| :------------ | :----------------------------------------------------------- |
| cd            | 更改工作目录到你的家目录。                                   |
| cd -          | 更改工作目录到先前的工作目录。                               |
| cd ~user_name | 更改工作目录到用户家目录。例如, cd ~bob 会更改工作目录到用户“bob”的家目录。 |
| cd .          | 到当前目录                                                   |
| cd ..         | 上一级目录                                                   |

有绝对路径和相对路径

相对路径中的`./` 是可以省略的，当前目录就是工作目录。

> - 以 . 开头的文件名是隐藏文件，ls -a显示
> - 没有文件扩展名的概念
> - 大小写敏感
> - 文件名可以包含空格、标点，但是标点仅限于".","-"和下划线，文件名不要包含空格，用下划线替代。

### 3. 研究操作系统

三个重要的命令：

- ls -lhtr
- file
- less(G:最后一行   1G或g:第一行    /character 查找字符串   n：下一个  q:退出)

##### Linux中的目录

| 目录     | 说明                                                       |
| -------- | ---------------------------------------------------------- |
| /boot    | Linux内核、启动程序等                                      |
| /dev     | Linux中一切都是文件，设备放在这里                          |
| /lib     | 核心系统程序需要的库，和windows的动态链接库类似            |
| /media   | USB、CD-ROM                                                |
| /mnt     | 可移除设备                                                 |
| /opt     | 预装在**系统**中的可选程序                                 |
| /proc    | Linux 内核维护的虚拟文件系统                               |
| /usr     | 用户的程序和文件，./lib  ./bin   ./share                   |
| /var     | 目录可能需要改变的文件存储的地方，数据库、假脱机文件在这里 |
| /var/log | 日志在这里， 可能需要root权限                              |

##### 软连接

同一个文件多个不同的文件名指向

### 4. 使用命令

- type – 说明怎样解释一个命令名
- which – 显示会执行哪个可执行程序
- man – 显示命令手册页
- apropos – 显示一系列适合的命令
- info – 显示命令 info
- whatis – 显示一个命令的简洁描述
- alias – 创建命令别名

### 5. 操作文件和目录

- cp — 复制文件和目录
- mv — 移动/重命名文件和目录
- mkdir — 创建目录
- rm — 删除文件和目录
- ln — 创建硬链接和符号链接

通配符：

| 通配符        | 意义                               |
| :------------ | :--------------------------------- |
| *             | 匹配任意多个字符（包括零个或一个） |
| ?             | 匹配任意一个字符（不包括零个）     |
| [characters]  | 匹配任意一个属于字符集中的字符     |
| [!characters] | 匹配任意一个不是字符集中的字符     |
| [[:class:]]   | 匹配任意一个属于指定字符类中的字符 |

##### 硬软链接

 在默认情况下，每个文件有一个硬链接，**这个硬链接给文件起名字**。当我们创建一个硬链接以后，就为文件创建了一个额外的目录条目。

一个硬链接和文件本身没有什么区别。

创建符号链接是为了克服硬链接的局限性。符号链接生效，是通过创建一个特殊类型的文件，这个文件包含一个关联文件或目录的**文本指针**。在这一方面， 它们和 Windows 的快捷方式差不多。

当你删除一个符号链接时，只有这个链接被删除，而不是文件自身。如果先于符号链接 删除文件，这个链接仍然存在，但是不指向任何东西。在这种情况下，这个链接被称为 **坏链接**。

> 当考虑到硬链接的时候，我们可以假设文件由两部分组成：包含文件内容的数据部分和持有文件名的名字部分 ，这将有助于我们理解这个概念。当我们创建文件硬链接的时候，实际上是为文件创建了额外的名字部分， 并且这些名字都关系到相同的数据部分。这时系统会分配一连串的磁盘给所谓的索引节点，然后索引节点与文 件名字部分相关联。因此每一个硬链接都关系到一个具体的包含文件内容的索引节点。

索引节点对应文件内容，硬链接对应文件名字。所以不同的硬链接对应的索引号是一致的。

只有当一个文件的所有硬链接被删除的时候，文件才会被删除。

**区别**：

> 建立符号链接的目的是为了克服硬链接的两个缺点：硬链接不能跨越物理设备， 硬链接不能关联目录，只能是文件。符号链接是文件的特殊类型，它包含一个指向目标文件或目录的文本指针。

执行的大多数文件操作是针对链接的对象，而不是链接本身。 **而 rm 命令是个特例**。当你删除链接的时候，删除链接本身，而不是链接的对象。

### 6. 重定向

> 与 Unix 主题“**任何东西都是一个文件**”保持一致，程序，比方说 ls，实际上把他们的运行结果 输送到一个叫做标准输出的特殊文件（经常用 stdout 表示），而它们的状态信息则送到另一个 叫做标准错误的文件（stderr）。默认情况下，标准输出和标准错误都连接到屏幕，而不是 保存到磁盘文件。除此之外，许多程序从一个叫做标准输入（stdin）的设备得到输入，默认情况下， 标准输入连接到键盘。
>
> I/O 重定向允许我们可以更改输出走向和输入来向。**一般地，输出送到屏幕，输入来自键盘， 但是通过 I/O 重定向，我们可以改变输入输出方向**。

- cat － 连接文件
- sort － 排序文本行
- uniq － 报道或省略重复行
- grep － 打印匹配行
- wc － 打印文件中换行符，字，和字节个数
- head － 输出文件第一部分
- tail - 输出文件最后一部分

##### 重定向标准输出

“>” 重定向符

```shell
[me@linuxbox ~]$ ls -l /usr/bin > ls-output.txt
```

">>"重定向符，追加：

```shell
[me@linuxbox ~]$ ls -l /usr/bin >> ls-output.txt
```

##### 重定向标准错误

文件流的前 三个看作标准输入，输出和错误，shell 内部参考它们为文件描述符0，1和2.

```shell
[me@linuxbox ~]$ ls -l /bin/usr 2> ls-error.txt
```

##### 重定向标准输出和错误到同一个文件

传统方法：

```shell
[me@linuxbox ~]$ ls -l /bin/usr > ls-output.txt 2>&1
```

现在的bash有新方法：

```shell
[me@linuxbox ~]$ ls -l /bin/usr &> ls-output.txt
```

##### cat - 连接文件

cat 命令读取一个或多个文件，然后复制它们到**标准输出**，就像这样:

```shell
cat [file]
```

**如果 cat 没有给出任何参数，它会从标准输入读入数据**，因为标准输入，默认情况下，连接到键盘。 它正在等待我们输入数据！

输入**Ctrl-d**，来告诉 cat，在标准输入中， 它已经到达文件末尾（EOF）

重定向标准输入：

```
[me@linuxbox ~]$ cat < lazy_dog.txt
The quick brown fox jumped over the lazy dog.
```

使用“<”重定向操作符，我们把标准输入源从键盘改到文件 lazy_dog.tx。我们看到**结果和传递单个文件名作为参数的执行结果一样**。把这和传递一个文件名参数作比较，尤其没有意义， 但它是用来说明把一个文件作为标准输入源。

##### 管道线

命令可以**从标准输入读取数据，然后再把数据输送到标准输出**，命令的这种能力被 一个 shell 特性所利用，这个特性叫做管道线。

```shell
command1 | command2
```

例子：

```shell
[me@linuxbox ~]$ ls -l /usr/bin | less
```

##### 过滤器和忽略重复

中间的都是过滤器

uniq删除重复

```shell
[panyliu@VM_0_6_centos ~]$ ls /bin /usr/bin/ | sort | less | wc -l
1399
[panyliu@VM_0_6_centos ~]$ ls /bin /usr/bin/ | sort | uniq |  less | wc -l
1386
```

例子2：可以看到重复的行，uniq的具体参数看手册

```shell
ls /bin /usr/bin/ | sort | uniq -d | less
```

##### wc － 打印行，字和字节数

默认是打印行数、字数、字节数和名字，可以加参数限制，比如-l，就只输出行

```shell
[panyliu@VM_0_6_centos ~]$ head helloworld 
I am a hero
[panyliu@VM_0_6_centos ~]$ wc helloworld 
 1  4 12 helloworld
```

##### grep － 打印匹配行

grep **用来找到文件中的匹配文本**,一般跟正则表达式配合使用：

```shell
grep pattern [file...]
```

例子：包含zip的文件，-v只打印不匹配的

```shell
[panyliu@VM_0_6_centos ~]$ ls /bin /usr/bin/ | grep zip | sort | uniq 
bunzip2
bzip2
bzip2recover
funzip
gpg-zip
gunzip
gzip
unzip
unzipsfx
zip
zipcloak
zipgrep
zipinfo
zipnote
zipsplit
```

##### head / tail － 打印文件开头部分/结尾部分

head 命令打印文件的**前十行**，而 tail 命令打印文件的**后十行**。默认情况下，两个命令 都打印十行文本，但是可以通过”-n”选项来调整命令打印的行数。

**tail 有一个选项允许你实时的浏览文件**。当观察日志文件的进展时，这很有用，因为 它们同时在被写入。在以下的例子里，我们要查看目录/var/log 里面的信息文件。在 一些 Linux 发行版中，要求有超级用户权限才能阅读这些文件，因为文件/var/log/messages 可能包含安全信息。

```
[me@linuxbox ~]$ tail -f /var/log/messages
Feb 8 13:40:05 twin4 dhclient: DHCPACK from 192.168.1.1
....
```

**使用”-f”选项，tail 命令继续监测这个文件**，当新的内容添加到文件后，它们会立即 出现在屏幕上。这会一直继续下去直到你输入 Ctrl-c。有一个命令叫tailf，是一样的。

##### tee － 从 Stdin 读取数据，并同时输出到 Stdout 和文件

tee 程序从标准输入读入数据，并且同时复制数据到标准输出（允许数据继续随着管道线流动）和一个或多个文件。（一边使数据继续沿着管道流动，一边可以标准输出）

```shell
cat helloworld  | tee hello2 |  grep my
```

上面这个例子，将helloworld中的内容输出到hello2的同时，继续传递下去。

### 7. 从shell眼中看世界

- 字符展开：通配符*
- 路径名展开：echo 的参数默认是当前文件夹下的所有文件名
- 波浪线展开：~ 工作目录
- 算数表达式展开：$((expr))   美元符号+两层括号
- 花括号展开：{}  分配， .. 是to的意思：1..3 ---> 1 to 3
- 参数展开：$USER    $  美元符号+0层括号
- 命令替换：echo $(ls)             $()  美元符号+单层括号
- 双引号：       * {} ~ 不能用  但是$可以用
- 单引号：    啥都不管用了

##### (字符)展开

echo 是一个 shell 内部命令，来完成非常简单的任务。 **它在标准输出中打印出它的文本参数**。

```shell
[me@linuxbox ~]$ echo *
Desktop Documents ls-output.txt Music Pictures Public Templates Videos
```

最简单的答案就是 shell 把“`*`”展开成了 另外的东西（在这种情况下，就是在当前工作目录下的文件名字），在 echo 命令被执行前。

##### 路径名展开

```shell
[panyliu@VM_0_6_centos play]$ ls
Hello  hello2  helloworld  LP  test.txt
[panyliu@VM_0_6_centos play]$ echo [hH]*
Hello hello2 helloworld
[panyliu@VM_0_6_centos play]$ 
```

隐藏路径展开，排除 .  和  ..

```shell
ls -d .[!.]?*
```

##### 波浪线展开

```shell
[panyliu@VM_0_6_centos play]$ echo ~
/home/panyliu
```

##### 算术表达式展开

形式：

```shell
$((expression))
```

例子：对空格不敏感，只能是整数，只能是数字，小数点都不行，支持：**+ - * / % ****

```shell
[panyliu@VM_0_6_centos /]$ echo $(($((5**2)) * 2))
50
```

##### 花括号展开

例子1：

```shell
[me@linuxbox ~]$ echo Front-{A,B,C}-Back
Front-A-Back Front-B-Back Front-C-Back
```

例子2：

```shell
[me@linuxbox ~]$ echo Number_{1..5}
Number_1  Number_2  Number_3  Number_4  Number_5
```

不能包含空格，可以倒序，可以嵌套

一个实用的例子：

```shell
[me@linuxbox ~]$ mkdir Pics
[me@linuxbox ~]$ cd Pics
[me@linuxbox Pics]$ mkdir {2007..2009}-0{1..9} {2007..2009}-{10..12}
[me@linuxbox Pics]$ ls
2007-01 2007-07 2008-01 2008-07 2009-01 2009-07
2007-02 2007-08 2008-02 2008-08 2009-02 2009-08
2007-03 2007-09 2008-03 2008-09 2009-03 2009-09
2007-04 2007-10 2008-04 2008-10 2009-04 2009-10
2007-05 2007-11 2008-05 2008-11 2009-05 2009-11
2007-06 2007-12 2008-06 2008-12 2009-06 2009-12
```

##### 参数展开

```shell
[panyliu@VM_0_6_centos ~]$ echo $USER
panyliu
```

##### 命令替换

命令替换允许我们把一个命令的输出作为一个展开模式来使用：

```shell
[panyliu@VM_0_6_centos ~]$ echo $(ls)
calcite play
```

例子：

```shell
[me@linuxbox ~]$ ls -l $(which cp)
-rwxr-xr-x 1 root root 71516 2007-12-05 08:58 /bin/cp
```

使用**倒引号**来代替美元符号和括号：

```shell
[me@linuxbox ~]$ ls -l `which cp`
-rwxr-xr-x 1 root root 71516 2007-12-05 08:58 /bin/cp
```

##### 引用

多余的空格会被自动剔除

```shell
[me@linuxbox ~]$ echo this is a    test
this is a test
```

##### 双引号

如果你把文本放在双引号中， shell 使用的特殊字符，除了 `$`，`\` (反斜杠），和 `（倒引号）之外， 则失去它们的特殊含义，被当作普通字符来看待。这意味着单词分割(被当做一个整体)，路径名展开（*被禁用）， 波浪线展开（~被禁用），和花括号展开都被禁止（{}被禁用），然而参数展开[$USER]，算术展开[$((2+2))]，和命令替换 仍然执行。

```shell
[me@linuxbox ~]$ ls -l "two words.txt"
-rw-rw-r-- 1 me   me   18 2008-02-20 13:03 two words.txt
[me@linuxbox ~]$ mv "two words.txt" two_words.txt
```

被双引号包裹的参数将作为一个整体传给echo

```shell
[panyliu@VM_0_6_centos play]$ echo `cal`
May 2020 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
[panyliu@VM_0_6_centos play]$ echo "`cal`"
      May 2020      
Su Mo Tu We Th Fr Sa
                1  2
 3  4  5  6  7  8  9
10 11 12 13 14 15 16
17 18 19 20 21 22 23
24 25 26 27 28 29 30
31
```

##### 单引号

如果需要禁止所有的展开，我们使用单引号。以下例子是无引用，双引号，和单引号的比较结果：

```shell
[me@linuxbox ~]$ echo text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER
text /home/me/ls-output.txt a b foo 4 me
[me@linuxbox ~]$ echo "text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER"
text ~/*.txt   {a,b} foo 4 me
[me@linuxbox ~]$ echo 'text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER'
text ~/*.txt  {a,b} $(echo foo) $((2+2)) $USER
```

正如我们所看到的，随着引用程度加强，越来越多的展开被禁止。

##### 转义字符

| 转义序列 | 含义                                   |
| -------- | -------------------------------------- |
| \a       | 响铃（”警告”－导致计算机嘟嘟响）       |
| \b       | 退格符                                 |
| \n       | 新的一行。在类 Unix 系统中，产生换行。 |
| \r       | 回车符                                 |
| \t       | 制表符                                 |

### 8. 键盘高级操作技巧

重要命令

- clear － 清空屏幕
- history － 显示历史列表内容

自动补全 tab

自动补全列表 tab tab

bash 维护着一个已经执行过的命令的历史列表。这个命令列表 被保存在你家目录下，一个叫做 **.bash_history** 的文件里。

在默认情况下，bash 会存储你所输入的最后 **500** 个命令。

以往使用过的命令   !number   eg. !88  编号为88的命令

启动递增搜索， 输入 Ctrl-r，其后输入你要寻找的文本。当你找到它以后，你可以敲入 Enter 来执行命令， 或者输入 Ctrl-j，从历史列表中复制这一行到当前命令行。**再次输入 Ctrl-r，来找到下一个 匹配项（向上移动历史列表）**。输入 Ctrl-g 或者 Ctrl-c，退出搜索。

```shell
(reverse-i-search)`/usr/bin': ls -l /usr/bin > ls-output.txt
```

**输入 Ctrl-j，复制它**

历史展开命令

| 序列     | 行为                                                         |
| :------- | :----------------------------------------------------------- |
| !!       | 重复最后一次执行的命令。可能按下上箭头按键和 enter 键更容易些。 |
| !number  | 重复历史列表中第 number 行的命令。                           |
| !string  | 重复最近历史列表中，以这个字符串开头的命令。                 |
| !?string | 重复最近历史列表中，包含这个字符串的命令。                   |

**慎用下面两个**：应该小心谨慎地使用 “!string” 和 “!?string” 格式，除非你完全确信历史列表条目的内容。

### 9. 权限

多用户系统

不能用户彼此之间受到影响。而且一个 用户的行为不能导致计算机崩溃，也不能乱动属于另一个用户的文件。

- id – 显示用户身份号
- chmod – 更改文件模式
- umask – 设置默认的文件权限
- su – 以另一个用户的身份来运行 shell
- sudo – 以另一个用户的身份来执行命令
- chown – 更改文件所有者
- chgrp – 更改文件组所有权
- passwd – 更改用户密码

##### 拥有者，组成员，和其他人

id: 从500开始

```shell
[me@linuxbox ~]$ id
uid=500(me) gid=500(me) groups=500(me)
```

ls -l之后的文件类型

| 属性 | 文件类型                                                     |
| :--- | :----------------------------------------------------------- |
| -    | 一个普通文件                                                 |
| d    | 一个目录                                                     |
| l    | 一个符号链接。注意对于符号链接文件，剩余的文件属性总是"rwxrwxrwx"，而且都是 虚拟值。真正的文件属性是指符号链接所指向的文件的属性。 |
| c    | 一个字符设备文件。这种文件类型是指按照字节流，来处理数据的设备。 比如说终端机，或者调制解调器 |
| b    | 一个块设备文件。这种文件类型是指按照数据块，来处理数据的设备，例如一个硬盘，或者 CD-ROM 盘。 |

##### chmod － 更改文件模式

八进制权限表示法：

| Octal | Binary | File Mode |
| :---- | :----- | :-------- |
| 0     | 000    | ---       |
| 1     | 001    | --x       |
| 2     | 010    | -w-       |
| 3     | 011    | -wx       |
| 4     | 100    | r--       |
| 5     | 101    | r-x       |
| 6     | 110    | rw-       |
| 7     | 111    | rwx       |

一般是755,775等等

常见的： **7 (rwx)，6 (rw-)，5 (r-x)，4 (r--)，和 0 (---)。**

chmod 命令符号表示法

|      |                                          |
| :--- | :--------------------------------------- |
| u    | "user"的简写，意思是文件或目录的所有者。 |
| g    | 用户组。                                 |
| o    | "others"的简写，意思是其他所有的人。     |
| a    | "all"的简写，是"u", "g"和“o”三者的联合。 |

##### umask － 设置默认权限

相应的数值是0002（0022是另一个常用值），这个数值是掩码的八进制 表示形式。下一步，我们创建文件 foo.txt，并且保留它的权限。

**哪一位有值，哪一位被掩码（相对于--- rw- rw- rw-而言）**

特殊权限：

- setuid 位（八进制4000)

- setgid 位（八进制2000）

- sticky 位（八进制1000）

例子：

> 一个程序被设置为setuid属性：
>
> -rwsr-xr-x
>
> 具有 setgid 属性的目录：
>
> drwxrwsr-x
>
> 设置了 sticky 位的目录：
>
> drwxrwxrwt

##### su － 以其他用户身份和组 ID 运行一个 shell

```shell
su [-[l]] [user]
```

如果不指定用户，那么就假定是 **超级用户**。注意（不可思议地），选项”-l”可以缩写为”-“，这是经常用到的形式。启动超级用户的 shell， 我们可以这样做：

```shell
[me@linuxbox ~]$ su -
Password:
[root@linuxbox ~]#
```

**输入超级用户的密码**

以这样的方式使用 su 命令，也可以只执行单个命令，而不是启动一个新的可交互的 shell：

```shell
su -c 'command'
```

注意：**不启动新的shell**

##### sudo － 以另一个用户身份执行命令

允许一个普通用户以不同的身份（通常是超级用户），通过一种非常可控的方式 来执行命令

另一个重要差异是 sudo 命令不要求超级用户的密码。使用 sudo 命令时，**用户使用他/她自己的密码来认证**

**在大多数的配置中，sudo 命令会相信你几分钟，直到计时结束。**

##### chown － 更改文件所有者和用户组

```shell
chown [owner][:[group]] file...
```

| 参数      | 结果                                                         |
| :-------- | :----------------------------------------------------------- |
| bob       | 把文件所有者从当前属主更改为用户 bob。                       |
| bob:users | 把文件所有者改为用户 bob，文件用户组改为用户组 users。       |
| :admins   | 把文件用户组改为组 admins，文件所有者不变。                  |
| bob:      | 文件所有者改为用户 bob，文件用户组改为，用户 bob 登录系统时，所属的用户组。 |

##### chgrp － 更改用户组所有权

##### 更改用户密码

```shell
passwd [user]
```

只要输入 passwd 命令，就能更改你的密码。

加user是更改其他的用户的密码。需要超级用户的权限。

### 10. 进程

- ps – 报告当前进程快照
- top – 显示任务
- jobs – 列出活跃的任务
- bg – 把一个任务放到后台执行
- fg – 把一个任务放到前台执行
- kill – 给一个进程发送信号
- killall – 杀死指定名字的进程
- shutdown – 关机或重启系统

##### 进程是怎样工作的

当系统启动的时候，内核先把一些它自己的程序初始化为进程，然后运行一个叫做 **init** 的程序。init， 依次地，再运行一系列的称为 **init 脚本的 shell 脚本**（位于/etc），它们可以启动所有的系统服务。 其中许多系统服务以**守护（daemon）程序**的形式实现，守护程序仅在后台运行，没有任何用户接口。 这样，即使我们没有登录系统，至少系统也在忙于执行一些例行事务。

一个程序可以发动另一个程序，这个事实在进程方案中，表述为一个**父进程创建了一个子进程**。

内核维护每个进程的信息，以此来保持事情有序。例如，系统分配给每个进程一个数字，这个数字叫做 **进程 ID 或 PID**。PID 号按升序分配，init 进程的 PID 总是1。内核也对分配给每个进程的内存进行跟踪。 像文件一样，进程也有所有者和用户 ID，有效用户 ID，等等。

##### 查看进程

```shell
[panyliu@VM_0_6_centos ~]$ ps
  PID TTY          TIME CMD
 2981 pts/1    00:00:00 ps
30417 pts/1    00:00:00 bash
```

 **TTY 是** “Teletype” 的简写，是指**进程的控制终端**。这里，Unix 展示它的年龄。TIME 字段表示 进程所消耗的 CPU 时间数量。

进程状态

| 状态 | 意义                                                         |
| :--- | :----------------------------------------------------------- |
| R    | 运行。这意味着，进程正在运行或准备运行。                     |
| S    | 正在睡眠。 进程没有运行，而是，正在等待一个事件， 比如说，一个按键或者网络数据包。 |
| D    | 不可中断睡眠。进程正在等待 I/O，比方说，一个磁盘驱动器的 I/O。 |
| T    | 已停止. 已经指示进程停止运行。稍后介绍更多。                 |
| Z    | 一个死进程或“僵尸”进程。这是一个已经终止的子进程，但是它的父进程还没有清空它。 （父进程没有把子进程从进程表中删除） |
| <    | 一个高优先级进程。这可能会授予一个进程更多重要的资源，给它更多的 CPU 时间。 进程的这种属性叫做 niceness。具有高优先级的进程据说是不好的（less nice）， 因为它占用了比较多的 CPU 时间，这样就给其它进程留下很少时间。 |
| N    | 低优先级进程。 一个低优先级进程（一个“好”进程）只有当其它高优先级进程执行之后，才会得到处理器时间。 |

常见 `ps aux`

```shell
[panyliu@VM_0_6_centos ~]$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.0   2900  1020 ?        Ss    2019   1:14 /sbin/init
root         2  0.0  0.0      0     0 ?        S     2019   0:00 [kthreadd]
root         3  0.0  0.0      0     0 ?        S     2019   0:00 [migration/0]
root         4  0.0  0.0      0     0 ?        S     2019   0:49 [ksoftirqd/0]
root         5  0.0  0.0      0     0 ?        S     2019   0:00 [stopper/0]
root         6  0.0  0.0      0     0 ?        S     2019   0:48 [watchdog/0]
root         7  0.0  0.0      0     0 ?        S     2019   8:34 [events/0]
more...
```

BSD 风格的 ps 命令列标题

| 标题  | 意思                                           |
| :---- | :--------------------------------------------- |
| USER  | 用户 ID. 进程的所有者。                        |
| %CPU  | 以百分比表示的 CPU 使用率                      |
| %MEM  | 以百分比表示的内存使用率                       |
| VSZ   | 虚拟内存大小                                   |
| RSS   | 进程占用的物理内存的大小，以千字节为单位。     |
| START | 进程运行的起始时间。若超过24小时，则用天表示。 |

##### 用 top 命令动态查看进程

```sh
top - 14:59:20 up 6:30, 2 users, load average: 0.07, 0.02, 0.00
Tasks: 109 total,   1 running,  106 sleeping,    0 stopped,    2 zombie
Cpu(s): 0.7%us, 1.0%sy, 0.0%ni, 98.3%id, 0.0%wa, 0.0%hi, 0.0%si
Mem:   319496k total,   314860k used,   4636k free,   19392k buff
Swap:  875500k total,   149128k used,   726372k free,  114676k cach

 PID  USER       PR   NI   VIRT   RES   SHR  S %CPU  %MEM   TIME+    COMMAND
6244  me         39   19  31752  3124  2188  S  6.3   1.0   16:24.42 trackerd
....
```

top 命令信息字段

| 行号          | 字段                                                         | 意义                                    |
| :------------ | :----------------------------------------------------------- | :-------------------------------------- |
| 1             | top                                                          | 程序名。                                |
| 14:59:20      | 当前时间。                                                   |                                         |
| up 6:30       | 这是正常运行时间。它是计算机从上次启动到现在所运行的时间。 在这个例子里，系统已经运行了六个半小时。 |                                         |
| 2 users       | 有两个用户登录系统。                                         |                                         |
| load average: | 加载平均值是指，等待运行的进程数目，也就是说，处于运行状态的进程个数， 这些进程共享 CPU。展示了三个数值，每个数值对应不同的时间周期。第一个是最后60秒的平均值， 下一个是前5分钟的平均值，最后一个是前15分钟的平均值。若平均值低于1.0，则指示计算机 工作不忙碌。 |                                         |
| 2             | Tasks:                                                       | 总结了进程数目和各种进程状态。          |
| 3             | Cpu(s):                                                      | 这一行描述了 CPU 正在执行的进程的特性。 |
| 0.7%us        | 0.7% of the CPU is being used for user processes. 这意味着进程在内核之外。 |                                         |
| 1.0%sy        | 1.0%的 CPU 时间被用于系统（内核）进程。                      |                                         |
| 0.0%ni        | 0.0%的 CPU 时间被用于"nice"（低优先级）进程。                |                                         |
| 98.3%id       | 98.3%的 CPU 时间是空闲的。                                   |                                         |
| 0.0%wa        | 0.0%的 CPU 时间来等待 I/O。                                  |                                         |
| 4             | Mem:                                                         | 展示物理内存的使用情况。                |
| 5             | Swap:                                                        | 展示交换分区（虚拟内存）的使用情况。    |

h，显示程序的帮助屏幕，q， 退出 top 程序。

##### 控制进程

- 中断一个进程：输入 Ctrl-c，中断一个程序  发送的是INT（中断）信号
- 把进程放到后台：在程序命令之后，加上”&”字符
- 进程回前台：fg %1
- 停止一个进程： 输入 Ctrl-z   发送的是TSTP（中断停止）信号

##### 通过 kill 命令给进程发送信号

```shell
kill [-signal] PID...
```

| 编号  | 名字  | 含义                                                         |
| ----- | ----- | ------------------------------------------------------------ |
| 1     | HUP   | 挂起。这是美好往昔的痕迹，那时候终端机通过电话线和调制解调器连接到 远端的计算机。这个信号被用来告诉程序，控制的终端机已经“挂起”。 通过关闭一个终端会话，可以说明这个信号的作用。发送这个信号到终端机上的前台程序，程序会终止。 |
| 2     | INT   | 中断。实现和 Ctrl-c 一样的功能，由终端发送。通常，它会**终止**一个程序。 |
| **9** | KILL  | **内核立即终止这个进程**。没有机会去做些“清理”工作，或者是保存劳动成果。 |
| 15    | TERM  | 终止。这是 kill 命令发送的**默认信号**。如果程序仍然“活着”，可以接受信号，那么 这个信号终止。 |
| 18    | CONT  | 继续。在停止一段时间后，进程恢复运行。                       |
| 19    | STOP  | **停止**。这个信号导致进程停止运行，而**没有终止**。像 KILL 信号，它不被发送到目标进程，因此它不能被忽略。 |
| 3     | QUIT  | 退出                                                         |
| 11    | SEGV  | 段错误。如果一个程序非法使用内存，就会发送这个信号。也就是说， 程序试图写入内存，而这个内存空间是不允许此程序写入的。 |
| 20    | TSTP  | 终端停止。当按下 Ctrl-z 组合键后，终端发送这个信号。不像 STOP 信号， TSTP 信号**由目标进程接收**，且可能被忽略。 |
| 28    | WINCH | 改变窗口大小。当改变窗口大小时，系统会发送这个信号。 一些程序，像 top 和 less 程序会响应这个信号，按照新窗口的尺寸，刷新显示的内容。 |

通过下面的命令可以得到一个完整的信号列表：

```shell
[me@linuxbox ~]$ kill -l
```

##### 通过 killall 命令给多个进程发送信号

```shell
killall [-u user] [-signal] name...
```

##### 更多和进程相关的命令

其它与进程相关的命令

| 命令名 | 命令描述                                                     |
| ------ | ------------------------------------------------------------ |
| pstree | 输出一个树型结构的进程列表，这个列表展示了进程间父/子关系。  |
| vmstat | 输出一个系统资源使用快照，包括内存，交换分区和磁盘 I/O。 为了看到连续的显示结果，则在命令名后加上延时的时间（以秒为单位）。例如，“vmstat 5”。 终止输出，按下 **Ctrl-c** 组合键。 |
| xload  | 一个图形界面程序，可以画出系统负载的图形。                   |
| tload  | 与 xload 程序相似，但是在终端中画出图形。使用 Ctrl-c，来终止输出。 |

底下两个好像没什么用。

### 11. shell环境

shell 在 shell 会话中维护着大量的信息，这些信息称为 (shell) 环境

shell 在环境中存储了两种基本类型的数据，虽然对于 bash 来说，很大程度上这些类型是不可辨别的。它们是**环境变量**和 **shell 变量**。Shell 变量是由 bash 存放的少量数据，而剩下的基本上 都是环境变量。除了变量，shell 也存储了一些可编程的数据，命名为别名和 shell 函数。

set 命令可以 显示 shell 和环境变量两者，而 printenv 只是显示环境变量。

##### 一些环境变量

| 变量    | 内容                                                         | 测试可用吗？ |
| :------ | :----------------------------------------------------------- | ------------ |
| DISPLAY | 如果你正在运行图形界面环境，那么这个变量就是你显示器的名字。通常，它是 ":0"， 意思是由 X 产生的第一个显示器。 | N            |
| EDITOR  | 文本编辑器的名字。                                           | N            |
| SHELL   | shell 程序的名字。                                           | Y            |
| HOME    | 用户家目录。                                                 | Y            |
| LANG    | 定义了字符集以及语言编码方式。                               | Y            |
| OLD_PWD | 先前的工作目录。                                             | N            |
| PAGER   | 页输出程序的名字。这经常设置为/usr/bin/less。                | N            |
| PATH    | 由冒号分开的目录列表，当你输入可执行程序名后，会搜索这个目录列表。 | Y            |
| PS1     | Prompt String 1. 这个定义了你的 shell 提示符的内容。随后我们可以看到，这个变量 内容可以全面地定制。 | Y            |
| PWD     | 当前工作目录。                                               | Y            |
| TERM    | 终端类型名。类 Unix 的系统支持许多终端协议；这个变量设置你的终端仿真器所用的协议。 | Y            |
| TZ      | 指定你所在的时区。大多数类 Unix 的系统按照协调时间时 (UTC) 来维护计算机内部的时钟 ，然后应用一个由这个变量指定的偏差来显示本地时间。 | N            |
| USER    | 你的用户名                                                   | Y            |

##### 如何建立 shell 环境？

登录系统后，启动 bash 程序，并且会读取一系列称为**启动文件的配置脚本**， 这些文件定义了默认的可供所有用户共享的 shell 环境。

有两种 shell 会话类型：一个是登录 shell 会话，另一个是非登录 shell 会话。

登录 shell 会话会提示用户输入用户名和密码；例如，我们启动一个虚拟控制台会话。当我们在 GUI 模式下 运行终端会话时，非登录 shell 会话会出现。

登录 shell 会读取一个或多个启动文件。

登录 shell 会话的启动文件：

| 文件                | 内容                                                         |
| :------------------ | :----------------------------------------------------------- |
| **/etc/profile**    | 应用于所有用户的全局配置脚本。                               |
| **~/.bash_profile** | 用户私人的启动文件。可以用来扩展或重写全局配置脚本中的设置。 |
| ~/.bash_login       | 如果文件 ~/.bash_profile 没有找到，bash 会尝试读取这个脚本。 |
| ~/.profile          | 如果文件 ~/.bash_profile 或文件 ~/.bash_login 都没有找到，bash 会试图读取这个文件。 这是基于 Debian 发行版的默认设置，比方说 Ubuntu。 |

非登录 shell 会话的启动文件

| 文件             | 内容                                                         |
| :--------------- | :----------------------------------------------------------- |
| /etc/bash.bashrc | 应用于所有用户的全局配置文件。                               |
| ~/.bashrc        | 用户私有的启动文件。可以用来扩展或重写全局配置脚本中的设置。 |

这是.bash_profile 的内容：

```sh
# .bash_profile

# Get the aliases and functions
if [ -f ~/.bashrc ]; then
        . ~/.bashrc
fi

# User specific environment and startup programs

PATH=$PATH:$HOME/bin

export PATH
```

这个 export 命令告诉 shell 让这个 shell 的**子进程可以使用 PATH 变量的内容**。

##### 我们应该修改哪个文件？

> 按照通常的规则，添加目录到你的 PATH 变量或者是定义额外的环境变量，要把这些更改放置到 .bash_profile 文件中（或者其替代文件中，根据不同的发行版。例如，Ubuntu 使用 .profile 文件）。 对于其它的更改，要放到 .bashrc 文件中。除非你是系统管理员，需要为系统中的所有用户修改 默认设置，那么则限定你只能对自己家目录下的文件进行修改。当然，有可能会更改 /etc 目录中的 文件，比如说 profile 文件，而且在许多情况下，修改这些文件也是明智的，但是现在，我们要 安全起见。

- 非管理员：
  - PATH 在 .bash_profile 中添加
  - 其他在 .bashrc 中添加

- 管理员：
  - PATH 在 /etc/profile 中添加
  - 其他在 /etc/bashrc 中添加

##### 激活修改

**source** 命令

对于文件 .bashrc 的修改不会生效，直到我们关闭终端会话，再重新启动一个新的会话， 因为 .bashrc 文件只是在刚开始启动终端会话时读取。然而，我们可以强迫 bash 重新读取修改过的 .bashrc 文件，使用下面的命令：

```
[me@linuxbox ~]$ source .bashrc
```

### 12. Vim

光标移动按键

| 按键                | 移动光标                                          |
| :------------------ | :------------------------------------------------ |
| l or 右箭头         | 向右移动一个字符                                  |
| h or 左箭头         | 向左移动一个字符                                  |
| j or 下箭头         | 向下移动一行                                      |
| k or 上箭头         | 向上移动一行                                      |
| 0 (零按键)          | 移动到当前行的行首。                              |
| ^                   | 移动到当前行的第一个非空字符。                    |
| $                   | 移动到当前行的末尾。                              |
| w                   | 移动到下一个单词或标点符号的开头。                |
| W                   | 移动到下一个单词的开头，忽略标点符号。            |
| b                   | 移动到上一个单词或标点符号的开头。                |
| B                   | 移动到上一个单词的开头，忽略标点符号。            |
| Ctrl-f or Page Down | 向下翻一页                                        |
| Ctrl-b or Page Up   | 向上翻一页                                        |
| numberG             | 移动到第 number 行。例如，1G 移动到文件的第一行。 |
| G                   | 移动到文件末尾。                                  |

##### 编辑

| 按键 | 插入       |
| ---- | ---------- |
| i    | 原地       |
| a    | 下一个字符 |
| o    | 下一行     |
| O    | 上一行     |

文本删除命令

| 命令 | 删除的文本                               |
| :--- | :--------------------------------------- |
| x    | 当前字符                                 |
| 3x   | 当前字符及其后的两个字符。               |
| dd   | 当前行。                                 |
| 5dd  | 当前行及随后的四行文本。                 |
| dW   | 从光标位置开始到下一个单词的开头。       |
| d$   | 从光标位置开始到当前行的行尾。           |
| d0   | 从光标位置开始到当前行的行首。           |
| d^   | 从光标位置开始到文本行的第一个非空字符。 |
| dG   | 从当前行到文件的末尾。                   |
| d20G | 从当前行到文件的第20行。                 |

这个 d 命令不仅删除文本，它还“**剪切**”文本。每次我们使用 d 命令，删除的部分被复制到一个 粘贴缓冲区中（看作剪切板）。过后我们执行小 p 命令把剪切板中的文本粘贴到光标位置之后， 或者是大 P 命令把文本粘贴到光标之前。

复制命令

| 命令 | 复制的内容                               |
| :--- | :--------------------------------------- |
| yy   | 当前行。                                 |
| 5yy  | 当前行及随后的四行文本。                 |
| yW   | 从当前光标位置到下一个单词的开头。       |
| y$   | 从当前光标位置到当前行的末尾。           |
| y0   | 从当前光标位置到行首。                   |
| y^   | 从当前光标位置到文本行的第一个非空字符。 |
| yG   | 从当前行到文件末尾。                     |
| y20G | 从当前行到文件的第20行。                 |

**u 命令会撤销我们的修改**

**大写的 J（不要与小写的 j 混淆了， j 是用来移动光标的）把行与行之间连接起来**

##### 查找和替换

f 命令查找一行，移动光标到下一个所指定的字符上。例如，命令 fa 会把光标定位到同一行中 下一个出现的”a”字符上。在一行中执行了字符的查找命令之后，通过输入分号来重复这个查找。

移动光标到下一个出现的单词或短语上，使用 / 命令。这个命令和我们之前在 less 程序中学到 的一样。当你输入/命令后，一个”/”字符会出现在屏幕底部。下一步，输入要查找的单词或短语后， 按下回车。光标就会移动到下一个包含所查找字符串的位置。**通过 n 命令来重复先前的查找**。N向前查找。

替换：

```shell
:%s/Line/line/g
```

每部分的含义：

| 条目       | 含义                                                         |
| :--------- | :----------------------------------------------------------- |
| :          | 冒号字符运行一个 ex 命令。                                   |
| %          | 指定要操作的行数。% 是一个快捷方式，表示从第一行到最后一行。另外，操作范围也 可以用 1,5 来代替（因为我们的文件只有5行文本），或者用 1,$ 来代替，意思是 “ 从第一行到文件的最后一行。” 如果省略了文本行的范围，那么操作只对当前行生效。 |
| s          | 指定操作。在这种情况下是，替换（查找与替代）。               |
| /Line/line | 查找类型与替代文本。                                         |
| g          | 这是“全局”的意思，意味着对文本行中所有匹配的字符串执行查找和替换操作。如果省略 g，则 只替换每个文本行中第一个匹配的字符串。 |

通过添加一个”c”字符到这个命令的末尾，来完成 这个替换命令.

```shell
:%s/line/Line/gc
```

##### 编辑多个文件

文件之间转换

从这个文件转到下一个文件，使用这个 ex 命令：

```
:n
```

回到先前的文件使用：

```
:N
```

查看正在编辑的文件列表，使用:buffers 命令。运行这个 命令后，屏幕顶部就会显示出一个文件列表：

```
:buffers
1 #     "foo.txt"                 line 1
2 %a    "ls-output.txt"           line 0
Press ENTER or type command to continue
```

注意：你不同通过:n 或:N 命令在由:e 命令加载的文件之间进行切换。这时要使用:buffer 命令， 其后加上缓冲区号码，来转换文件。

```shell
:buffer 1
```

##### 插入文本

只打开一个文件的 vi 会话

以下 ex 命令：

```shell
:r foo.txt
```

这个**:r 命令**（是”read”的简称）把指定的文件插入到光标位置之前。

##### 退出

- 在命令模式下，输入 **ZZ** 就会保存并退出当前文件

- ex 命令:wq 把:w 和:q 命令结合到 一起，来完成保存和退出任务
- :w 命令也可以指定可选的文件名。这个的作用就如”Save As…“。

### 13. 自定义shell提示符

```shell
[panyliu@VM_0_6_centos ~]$ echo $PS1
[\u@\h \W]\$
```

| 序列 | 显示值                                                       |
| :--- | :----------------------------------------------------------- |
| \a   | 以 ASCII 格式编码的铃声 . 当遇到这个转义序列时，计算机会发出嗡嗡的响声。 |
| \d   | 以日，月，天格式来表示当前日期。例如，“Mon May 26.”          |
| \h   | 本地机的主机名，但不带末尾的域名。                           |
| \H   | 完整的主机名。                                               |
| \j   | 运行在当前 shell 会话中的工作数。                            |
| \l   | 当前终端设备名。                                             |
| \n   | 一个换行符。                                                 |
| \r   | 一个回车符。                                                 |
| \s   | shell 程序名。                                               |
| \t   | 以24小时制，hours:minutes:seconds 的格式表示当前时间.        |
| \T   | 以12小时制表示当前时间。                                     |
| @    | 以12小时制，AM/PM 格式来表示当前时间。                       |
| \A   | 以24小时制，hours:minutes 格式表示当前时间。                 |
| \u   | 当前用户名。                                                 |
| \v   | shell 程序的版本号。                                         |
| \V   | Version and release numbers of the shell.                    |
| \w   | 当前工作目录名。                                             |
| \W   | 当前工作目录名的最后部分。                                   |
| !    | 当前命令的历史号。                                           |
| #    | 当前 shell 会话中的命令数。                                  |
| $    | 这会显示一个"$"字符，除非你拥有超级用户权限。在那种情况下， 它会显示一个"#"字符。 |
| [    | 标志着一系列一个或多个非打印字符的开始。这被用来嵌入非打印 的控制字符，这些字符以某种方式来操作终端仿真器，比方说移动光标或者是更改文本颜色。 |
| ]    | 标志着非打印字符序列结束。                                   |

用转义序列来设置文本颜色

这些颜色被分为两组，由应用程序**粗体**字符属性（1） 分化开来，这个属性可以描绘出“浅”色文本。

| 序列       | 文本颜色 | 序列       | 文本颜色 |
| :--------- | :------- | :--------- | :------- |
| \033[0;30m | 黑色     | \033[1;30m | 深灰色   |
| \033[0;31m | 红色     | \033[1;31m | 浅红色   |
| \033[0;32m | 绿色     | \033[1;32m | 浅绿色   |
| \033[0;33m | 棕色     | \033[1;33m | 黄色     |
| \033[0;34m | 蓝色     | \033[1;34m | 浅蓝色   |
| \033[0;35m | 粉红     | \033[1;35m | 浅粉色   |
| \033[0;36m | 青色     | \033[1;36m | 浅青色   |
| \033[0;37m | 浅灰色   | \033[1;37m | 白色     |
| \033[0;40m | 蓝色     | \033[1;44m | 黑色     |
| \033[0;41m | 红色     | \033[1;45m | 粉红     |
| \033[0;42m | 绿色     | \033[1;46m | 青色     |
| \033[0;43m | 棕色     | \033[1;47m | 浅灰色   |

除了正常的 (0) 和黑体 (1) 字符属性之外，文本也可以具有下划线 (4)，闪烁 (5)， 和反向 (7) 属性。

### 14. 软件包管理

不同的 Linux 发行版使用不同的打包系统，一般而言，大多数发行版分别属于两大包管理技术阵营： Debian 的”.deb”，和红帽的”.rpm”。也有一些重要的例外，比方说 Gentoo， Slackware，和 Foresight，但大多数会使用这两个基本系统中的一个。

主要的包管理系统家族

| 包管理系统           | 发行版 (部分列表)                                            |
| :------------------- | :----------------------------------------------------------- |
| Debian Style (.deb)  | Debian, Ubuntu, Xandros, Linspire                            |
| Red Hat Style (.rpm) | Fedora, CentOS, Red Hat Enterprise Linux, OpenSUSE, Mandriva, PCLinuxOS |

包管理工具

| 发行版                                   | 底层工具 | 上层工具          |
| :--------------------------------------- | :------- | :---------------- |
| Debian-Style                             | dpkg     | apt-get, aptitude |
| Fedora, Red Hat Enterprise Linux, CentOS | rpm      | yum               |

Centos常用命令（红帽系）

| 功能                       | 命令                     |
| -------------------------- | ------------------------ |
| 查找                       | yum search search_string |
| 安装                       | yum install package_name |
| rpm安装                    | rpm -i package_file      |
| 卸载                       | yum erase package_name   |
| 更新所有                   | yum update               |
| 升级                       | rpm -U package_file      |
| 列出所安装的软件包         | rpm -qa                  |
| 确定是否安装了一个软件包   | rpm -q package_name      |
| 显示所安装软件包的信息     | yum info package_name    |
| 查找安装了某个文件的软件包 | rpm -qf file_name        |

### 15. 存储媒介

- mount – 挂载一个文件系统
- umount – 卸载一个文件系统
- fsck – 检查和修复一个文件系统
- fdisk – 分区表控制器
- mkfs – 创建文件系统
- fdformat – 格式化一张软盘
- dd — 把面向块的数据直接写入设备
- genisoimage (mkisofs) – 创建一个 ISO 9660的映像文件
- wodim (cdrecord) – 把数据写入光存储媒介
- md5sum – 计算 MD5检验码

##### 挂载和卸载存储设备

把设备连接到文件系统树中。这个过程叫做挂载，允许设备参与到操作系统中。

/etc/fstab 字段

| 字段 | 内容         | 说明                                                         |
| :--- | :----------- | :----------------------------------------------------------- |
| 1    | 设备名       | 传统上，这个字段包含与物理设备相关联的设备文件的实际名字，比如说/dev/hda1（第一个 IDE 通道上第一个主设备分区）。然而今天的计算机，有很多热插拔设备（像 USB 驱动设备），许多 现代的 Linux 发行版用一个文本标签和设备相关联。当这个设备连接到系统中时， 这个标签（当储存媒介格式化时，这个标签会被添加到存储媒介中）会被操作系统读取。 那样的话，不管赋给实际物理设备哪个设备文件，这个设备仍然能被系统正确地识别。 |
| 2    | 挂载点       | 设备所连接到的文件系统树的目录。                             |
| 3    | 文件系统类型 | Linux 允许挂载许多文件系统类型。大多数本地的 Linux 文件系统是 ext3， 但是也支持很多其它的，比方说 FAT16 (msdos), FAT32 (vfat)，NTFS (ntfs)，CD-ROM (iso9660)，等等。 |
| 4    | 选项         | 文件系统可以通过各种各样的选项来挂载。有可能，例如，挂载只读的文件系统， 或者挂载阻止执行任何程序的文件系统（一个有用的安全特性，避免删除媒介。） |
| 5    | 频率         | 一位数字，指定是否和在什么时间用 dump 命令来备份一个文件系统。 |
| 6    | 次序         | 一位数字，指定 fsck 命令按照什么次序来检查文件系统。         |

 **mount 命令被用来挂载文件系统**。执行这个不带参数的命令，将会显示 一系列当前挂载的文件系统：

**一个挂载点就是文件系统树中的一个目录**。它没有 什么特殊的。它甚至不必是一个空目录，即使你把设备挂载到了一个非空目录上，你也不能看到 这个目录中原来的内容，直到你卸载这个设备。

```shell
[root@linuxbox ~]# mount -t iso9660 /dev/hdc /mnt/cdrom
```

之后，我们可以通过这个新挂载点来查看 CD-ROW 的内容：

```shell
[root@linuxbox ~]# cd /mnt/cdrom
[root@linuxbox cdrom]# ls
```

> 为什么卸载重要?
>
> 卸载一个设备**需要把所有剩余的数据写入这个设备**，所以设备可以被安全地移除。如果没有卸载设备，就移除了它，就有可能没有把注定要发送到设备中的数据输送完毕。在某些情况下， 这些数据可能包含重要的目录更新信息，这将导致文件系统损坏，这是发生在计算机中的最坏的事情之一。

##### 确定设备名称

Linux 存储设备名称

| 模式     | 设备                                                         |
| :------- | :----------------------------------------------------------- |
| /dev/fd* | 软盘驱动器                                                   |
| /dev/hd* | 老系统中的 IDE(PATA)磁盘。典型的主板包含两个 IDE 连接器或者是通道，每个连接器 带有一根缆线，每根缆线上有两个硬盘驱动器连接点。缆线上的第一个驱动器叫做主设备， 第二个叫做从设备。设备名称这样安排，/dev/hdb 是指第一通道上的主设备名；/dev/hdb 是第一通道上的从设备名；/dev/hdc 是第二通道上的主设备名，等等。末尾的数字表示 硬盘驱动器上的分区。例如，/dev/hda1是指系统中第一硬盘驱动器上的第一个分区，而 /dev/hda 则是指整个硬盘驱动器。 |
| /dev/lp* | 打印机                                                       |
| /dev/sd* | SCSI 磁盘。<u>在最近的 Linux 系统中，内核把所有类似于磁盘的设备（包括 PATA/SATA 硬盘， 闪存，和 USB 存储设备，比如说可移动的音乐播放器和数码相机）看作 SCSI 磁盘。 剩下的命名系统类似于上述所描述的旧的/dev/hd*命名方案。</u> |
| /dev/sr* | 光盘（CD/DVD 读取器和烧写器）                                |

以下方式查看设备名：

```shell
[me@linuxbox ~]$ sudo tail -f /var/log/messages
```

##### 创建新的文件系统

1. 创建一个新的分区（可选）。

2. 在这个分区上创建一个新的空的文件系统。

##### 用 fdisk 命令操作分区

```shell
[me@linuxbox ~]$ sudo umount /dev/sdb1
[me@linuxbox ~]$ sudo fdisk /dev/sdb
```

细节到时候再看吧。

##### 用 mkfs 命令创建一个新的文件系统

```shell
[me@linuxbox ~]$ sudo mkfs -t vfat /dev/sdb1
```

##### 测试和修复文件系统

 在挂载系统之前，都会按照惯例检查文件系统的完整性。这个任务由 **fsck** 程序（是”file system check”的简写）完成。每个 fstab 项中的最后一个数字指定了设备的检查顺序。 在上面的实例中，我们看到首先检查根文件系统，然后是 home 和 boot 文件系统。

**文件系统损坏情况相当罕见**，除非硬件存在问题，如磁盘驱动器故障。

##### 其他实现

| 功能                       | 命令                                                         |
| -------------------------- | ------------------------------------------------------------ |
| 格式化软盘                 | sudo **fdformat** /dev/fd0                                   |
| 直接把数据移入/出设备      | **dd** if=/dev/sdb of=/dev/sdc <br />**dd** if=/dev/sdb of=flash_drive.img |
| 创建一个 CD-ROM 的映像拷贝 | **dd** if=/dev/cdrom of=ubuntu.iso                           |
| 从文件集合中创建一个映像   | **genisoimage** -o cd-rom.iso -R -J ~/cd-rom-files           |
| 直接挂载一个 ISO 镜像      | **mount** -t iso9660 -o loop image.iso /mnt/iso_image        |
| 清除一张可重写入的 CD-ROM  | **wodim** dev=/dev/cdrw blank=fast                           |
| 写入镜像                   | **wodim** dev=/dev/cdrw image.iso                            |
| 验证iso镜像                | **md5sum** image.iso                                         |

### 16. 网络系统

当谈及到网络系统层面，几乎任何东西都能由 Linux 来实现。

Linux 被用来创建各式各样的网络系统和装置， 包括防火墙，路由器，名称服务器，网络连接式存储设备等等。

- ping - 发送 ICMP ECHO_REQUEST 软件包到网络主机
- traceroute - 打印到一台网络主机的路由数据包
- netstat - 打印网络连接，路由表，接口统计数据，伪装连接，和多路广播成员
- ftp - 因特网文件传输程序
- wget - 非交互式网络下载器
- ssh - OpenSSH SSH 客户端（远程登录程序）

##### 检查和监测网络

###### ping

 ping 命令发送一个特殊的网络数据包，叫做 IMCP ECHO_REQUEST，到 一台指定的主机。大多数接收这个包的网络设备将会回复它，来允许网络连接验证。

```shell
[me@linuxbox ~]$ ping linuxcommand.org
PING linuxcommand.org (66.35.250.210) 56(84) bytes of data.
64 bytes from vhost.sourceforge.net (66.35.250.210): icmp\_seq=1
ttl=43 time=107 ms
64 bytes from vhost.sourceforge.net (66.35.250.210): icmp\_seq=2
ttl=43 time=108 ms
64 bytes from vhost.sourceforge.net (66.35.250.210): icmp\_seq=3
ttl=43 time=106 ms
...
```

###### traceroute

traceroute 程序（一些系统使用相似的 tracepath 程序来代替）会显示从本地到指定主机要经过的所有“跳数”的网络流量列表。

```shell
[me@linuxbox ~]$ traceroute slashdot.org
traceroute to slashdot.org (216.34.181.45), 30 hops max, 40 byte
packets
1 ipcop.localdomain (192.168.1.1) 1.066 ms 1.366 ms 1.720 ms
2 * * *
3 ge-4-13-ur01.rockville.md.bad.comcast.net (68.87.130.9) 14.622
ms 14.885 ms 15.169 ms
4 po-30-ur02.rockville.md.bad.comcast.net (68.87.129.154) 17.634
ms 17.626 ms 17.899 ms
5 po-60-ur03.rockville.md.bad.comcast.net (68.87.129.158) 15.992
ms 15.983 ms 16.256 ms
6 po-30-ar01.howardcounty.md.bad.comcast.net (68.87.136.5) 22.835
...
```

###### netstat

netstat 程序被用来检查各种各样的网络设置和统计数据。通过此命令的许多选项，我们 可以看看网络设置中的各种特性。

```shell
[me@linuxbox ~]$ netstat -ie
eth0    Link encap:Ethernet HWaddr 00:1d:09:9b:99:67
        inet addr:192.168.1.2 Bcast:192.168.1.255 Mask:255.255.255.0
        inet6 addr: fe80::21d:9ff:fe9b:9967/64 Scope:Link
        UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
        RX packets:238488 errors:0 dropped:0 overruns:0 frame:0
        TX packets:403217 errors:0 dropped:0 overruns:0 carrier:0
        collisions:0 txqueuelen:100 RX bytes:153098921 (146.0 MB) TX
        bytes:261035246 (248.9 MB) Memory:fdfc0000-fdfe0000

lo      Link encap:Local Loopback
        inet addr:127.0.0.1 Mask:255.0.0.0
...
```

##### 网络中传输文件

###### ftp

FTP（它的原始形式）并不是安全的，因为它会**以明码形式发送帐号的姓名和密码**。这就意味着 这些数据没有加密，任何嗅探网络的人都能看到。由于此种原因，几乎因特网中所有 FTP 服务器 都是匿名的。一个匿名服务器能允许任何人使用注册名“anonymous”和无意义的密码登录系统。

使用 ftp 程序下载一个 Ubuntu 系统映像文件。

```shell
[me@linuxbox ~]$ ftp fileserver
Connected to fileserver.localdomain.
220 (vsFTPd 2.0.1)
Name (fileserver:me): anonymous
331 Please specify the password.
Password:
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> cd pub/cd\_images/Ubuntu-8.04
250 Directory successfully changed.
ftp> ls
200 PORT command successful. Consider using PASV.
150 Here comes the directory listing.
-rw-rw-r-- 1 500 500 733079552 Apr 25 03:53 ubuntu-8.04- desktop-i386.iso
226 Directory send OK.
ftp> lcd Desktop
Local directory now /home/me/Desktop
ftp> get ubuntu-8.04-desktop-i386.iso
local: ubuntu-8.04-desktop-i386.iso remote: ubuntu-8.04-desktop-
i386.iso
200 PORT command successful. Consider using PASV.
150 Opening BINARY mode data connection for ubuntu-8.04-desktop-
i386.iso (733079552 bytes).
226 File send OK.
733079552 bytes received in 68.56 secs (10441.5 kB/s)
ftp> bye
```

###### lftp

ftp 并不是唯一的命令行形式的 FTP 客户端。实际上，还有很多。其中比较好（也更流行的）是 lftp 程序。

###### wget

若想从网络和 FTP 网站两者上都能下载数据，wget 是很有用处的。 不只能下载单个文件，多个文件，甚至整个网站都能下载。

```shell
[me@linuxbox ~]$ wget http://linuxcommand.org/index.php
--11:02:51-- http://linuxcommand.org/index.php
        => `index.php'
Resolving linuxcommand.org... 66.35.250.210
Connecting to linuxcommand.org|66.35.250.210|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: unspecified [text/html]

  [ <                        => ]        3,120       --.--K/s

11:02:51 (161.75 MB/s) - 'index.php' saved [3120]
```

##### 与远程主机安全通信

通过网络来远程操控类 Unix 的操作系统已经有很多年了。早些年，在因特网普遍推广之前，有 一些受欢迎的程序被用来登录远程主机。它们是 **rlogin 和 telnet 程序**。然而这些程序，拥有和 ftp 程序 一样的致命缺点；它们**以明码形式来传输所有的交流信息**（包括登录命令和密码）。这使它们完全不适合使用在因特网时代。

###### ssh

SSH 解决了这两个基本的和远端主机安全交流的问题。首先，它要**认证**远端主机是否为它所知道的那台主机（这样就阻止了所谓的“中间人”的攻击），其次，它**加密**了本地与远程主机之间 所有的通讯信息。

SSH 由两部分组成。**SSH 服务器**运行在远端主机上运行，在**端口号22**上监听将要到来的连接，而 **SSH 客户端**用在本地系统中，用来和远端服务器通信。

使用 ssh 客户端程序：

```shell
[me@linuxbox ~]$ ssh remote-sys
The authenticity of host 'remote-sys (192.168.1.4)' can't be
established.
RSA key fingerprint is
41:ed:7a:df:23:19:bf:3c:a5:17:bc:61:b3:7f:d9:bb.
Are you sure you want to continue connecting (yes/no)?
```

第一次尝试连接，提示信息表明远端主机的真实性不能确立。这是因为客户端程序以前从没有 看到过这个远端主机。为了接受远端主机的身份验证凭据，输入“yes”。一旦建立了连接，会提示 用户输入他或她的密码：

```shell
Warning: Permanently added 'remote-sys,192.168.1.4' (RSA) to the list
of known hosts.
me@remote-sys's password:
```

成功地输入密码之后，我们会接收到远端系统的 **shell 提示符**：

远端 shell 会话一直存在，直到用户输入 exit 命令后，则关闭了远程连接。这时候，本地的 shell 会话 恢复，本地 shell 提示符重新出现。

```shell
[me@linuxbox ~]$ ssh bob@remote-sys
bob@remote-sys's password:
Last login: Sat Aug 30 13:03:21 2008
[bob@remote-sys ~]$
```

> SSH 协议允许大多数 网络流量类型通过这条加密通道来被传送，在本地与远端系统之间创建某种 VPN（虚拟专用网络）。
>
> 可能这个特性的最普遍使用是允许传递 X 窗口系统流量。在运行着 X 服务器（也就是， 能显示 GUI 的机器）的系统中，有可能在远端启动和运行一个 X 客户端程序（一个图形化应用程序）， 而应用程序的显示结果出现在本地。
>
> ```shell
> [me@linuxbox ~]$ ssh -X remote-sys
> me@remote-sys's password:
> Last login: Mon Sep 08 13:23:11 2008
> [me@remote-sys ~]$ xload
> ```

###### scp 和 sftp

OpenSSH 软件包也包含两个程序，它们可以利用 SSH 加密通道在网络间复制文件。

 第一个，**scp（安全复制）被用来复制文件**，与熟悉的 cp 程序非常相似。最显著的区别就是**源或者目标路径名要以远端主机的名字，后跟一个冒号字符开头**。例如，如果我们想要 从远端系统，remote-sys，的家目录下复制文档 document.txt，到我们本地系统的当前工作目录下， 可以这样操作：

```shell
[me@linuxbox ~]$ scp remote-sys:document.txt .
me@remote-sys's password:
document.txt
100%        5581        5.5KB/s         00:00
[me@linuxbox ~]$
```

第二个 SSH 文件复制命令是 sftp。sftp 工作起来与我们 之前使用的 ftp 程序很相似；然而，它不用明码形式来传递数据，它使用加密的 SSH 通道。sftp 有一个重要特性强于传统的 ftp 命令，就是 sftp 不需要远端系统中运行 FTP 服务器。它**仅仅要求 SSH 服务器**。 这意味着任何一台能用 SSH 客户端连接的远端机器，也可当作类似于 FTP 的服务器来使用。 

```shell
[me@linuxbox ~]$ sftp remote-sys
Connecting to remote-sys...
me@remote-sys's password:
sftp> ls
ubuntu-8.04-desktop-i386.iso
sftp> lcd Desktop
sftp> get ubuntu-8.04-desktop-i386.iso
Fetching /home/me/ubuntu-8.04-desktop-i386.iso to ubuntu-8.04-
desktop-i386.iso
/home/me/ubuntu-8.04-desktop-i386.iso 100% 699MB 7.4MB/s 01:35
sftp> bye
```

### 18. 查找文件

- locate – 通过名字来查找文件
- find – 在目录层次结构中搜索文件
- xargs – 从标准输入生成和执行命令行
- touch – 更改文件时间
- stat – 显示文件或文件系统状态

##### locate - 查找文件的简单方法

```shell
[me@linuxbox ~]$ locate bin/zip
/usr/bin/zip
/usr/bin/zipcloak
/usr/bin/zipgrep
/usr/bin/zipinfo
/usr/bin/zipnote
/usr/bin/zipsplit
```

> locate 数据库由另一个叫做 updatedb 的程序创建。通常，这个程序作为一个 cron 工作例程周期性运转；也就是说，一个任务 在特定的时间间隔内被 cron 守护进程执行。大多数装有 locate 的系统会每隔一天运行一回 updatedb 程序。因为数据库不能被持续地更新，所以当使用 locate 时，你会发现 目前最新的文件不会出现。为了克服这个问题，可以手动运行 updatedb 程序， 更改为超级用户身份，在提示符下运行 updatedb 命令。

##### find - 查找文件的复杂方式

###### Tests

比如说我们想要目录列表。我们可以添加以下测试条件：

```shell
[me@linuxbox ~]$ find ~ -type d | wc -l
1695
```

添加测试条件-type d 限制了只搜索目录。相反地，我们使用这个测试条件来限定搜索普通文件：

```shell
[me@linuxbox ~]$ find ~ -type f | wc -l
38737
```

find 文件类型

| 文件类型 | 描述         |
| :------- | :----------- |
| b        | 块设备文件   |
| c        | 字符设备文件 |
| d        | 目录         |
| f        | 普通文件     |
| l        | 符号链接     |

可以通过加入一些额外的测试条件，根据文件大小和文件名来搜索：让我们查找所有文件名匹配 通配符模式“*.JPG”和文件大小大于1M 的文件：

```shell
[me@linuxbox ~]$ find ~ -type f -name "\*.JPG" -size +1M | wc -l
840
```

find 大小单位

| 字符 | 单位                                           |
| :--- | :--------------------------------------------- |
| b    | 512 个字节块。如果没有指定单位，则这是默认值。 |
| c    | 字节                                           |
| w    | 两个字节的字                                   |
| k    | 千字节(1024个字节单位)                         |
| M    | 兆字节(1048576个字节单位)                      |
| G    | 千兆字节(1073741824个字节单位)                 |

find 测试条件

| 测试条件       | 描述                                                         |
| :------------- | :----------------------------------------------------------- |
| -cmin n        | 匹配的文件和目录的内容或属性最后修改时间正好在 n 分钟之前。 指定少于 n 分钟之前，使用 -n，指定多于 n 分钟之前，使用 +n。 |
| -cnewer file   | 匹配的文件和目录的内容或属性最后修改时间早于那些文件。       |
| -ctime n       | 匹配的文件和目录的内容和属性最后修改时间在 n*24小时之前。    |
| -empty         | 匹配空文件和目录。                                           |
| -group name    | 匹配的文件和目录属于一个组。组可以用组名或组 ID 来表示。     |
| -iname pattern | 就像-name 测试条件，但是不区分大小写。                       |
| -inum n        | 匹配的文件的 inode 号是 n。这对于找到某个特殊 inode 的所有硬链接很有帮助。 |
| -mmin n        | 匹配的文件或目录的内容被修改于 n 分钟之前。                  |
| -mtime n       | 匹配的文件或目录的内容被修改于 n*24小时之前。                |
| -name pattern  | 用指定的通配符模式匹配的文件和目录。                         |
| -newer file    | 匹配的文件和目录的内容早于指定的文件。当编写 shell 脚本，做文件备份时，非常有帮助。 每次你制作一个备份，更新文件（比如说日志），然后使用 find 命令来决定自从上次更新，哪一个文件已经更改了。 |
| -nouser        | 匹配的文件和目录不属于一个有效用户。这可以用来查找 属于删除帐户的文件或监测攻击行为。 |
| -nogroup       | 匹配的文件和目录不属于一个有效的组。                         |
| -perm mode     | 匹配的文件和目录的权限已经设置为指定的 mode。mode 可以用 八进制或符号表示法。 |
| -samefile name | 相似于-inum 测试条件。匹配和文件 name 享有同样 inode 号的文件。 |
| -size n        | 匹配的文件大小为 n。                                         |
| -type c        | 匹配的文件类型是 c。                                         |
| -user name     | 匹配的文件或目录属于某个用户。这个用户可以通过用户名或用户 ID 来表示。 |

find 命令的逻辑操作符

| 操作符 | 描述                                                         |
| :----- | :----------------------------------------------------------- |
| -and   | 如果操作符两边的测试条件都是真，则匹配。可以简写为 -a。 注意若没有使用操作符，则默认使用 -and。 |
| -or    | 若操作符两边的任一个测试条件为真，则匹配。可以简写为 -o。    |
| -not   | 若操作符后面的测试条件是真，则匹配。可以简写为一个感叹号（!）。 |
| ()     | 把测试条件和操作符组合起来形成更大的表达式。这用来控制逻辑计算的优先级。 默认情况下，find 命令按照从左到右的顺序计算。经常有必要重写默认的求值顺序，以得到期望的结果。 即使没有必要，有时候包括组合起来的字符，对提高命令的可读性是很有帮助的。注意 因为圆括号字符对于 shell 来说有特殊含义，所以在命令行中使用它们的时候，它们必须 用引号引起来，才能作为实参传递给 find 命令。通常反斜杠字符被用来转义圆括号字符。 |

```shell
( expression 1 ) -or ( expression 2 )
```

例子：

```shell
find ~ ( -type f -not -perms 0600 ) -or ( -type d -not -perms 0700 )
```

###### 预定义的操作

几个预定义的 find 命令操作

| 操作    | 描述                                                         |
| :------ | :----------------------------------------------------------- |
| -delete | 删除当前匹配的文件。                                         |
| -ls     | 对匹配的文件执行等同的 ls -dils 命令。并将结果发送到标准输出。 |
| -print  | 把匹配文件的全路径名输送到标准输出。如果没有指定其它操作，这是 默认操作。 |
| -quit   | 一旦找到一个匹配，退出。                                     |

例子：

```shell
find ~ -type f -name '*.BAK' -delete
```

###### 用户定义的行为

传统方式是通过 -exec 行为。这个 行为像这样工作：

```shell
-exec command {} ;
```

因为花括号和分号对于 shell 有特殊含义，所以它们必须被引起来或被转义。

```shell
-exec rm '{}' ';'
```

通过使用 -ok 行为来代替 -exec，在执行每个指定的命令之前， 会提示用户：

```shell
find ~ -type f -name 'foo*' -ok ls -l '{}' ';'
< ls ... /home/me/bin/foo > ? y
-rwxr-xr-x 1 me    me 224 2007-10-29 18:44 /home/me/bin/foo
< ls ... /home/me/foo.txt > ? y
-rw-r--r-- 1 me    me 0 2008-09-19 12:53 /home/me/foo.
```

###### xargs

xargs 命令会执行一个有趣的函数。它**从标准输入接受输入，并把输入转换为一个特定命令的参数列表**。对于我们的例子，我们可以这样使用它：

```
find ~ -type f -name 'foo\*' -print | xargs ls -l
-rwxr-xr-x 1 me     me 224 2007-10-29 18:44 /home/me/bin/foo
-rw-r--r-- 1 me     me 0 2008-09-19 12:53 /home/me/foo.txt
```

这里我们看到 find 命令的输出被管道到 xargs 命令，反过来，xargs 会为 ls 命令构建 参数列表，然后执行 ls 命令。

##### 例子

创建一个包含许多子目录和文件的操练场：

```shell
[me@linuxbox ~]$ mkdir -p playground/dir-{00{1..9},0{10..99},100}
[me@linuxbox ~]$ touch playground/dir-{00{1..9},0{10..99},100}/file-{A..Z}
```

创建了一百个名为 file-A 的文件实例。让我们找到它们：

```shell
[me@linuxbox ~]$ find playground -type f -name 'file-A | wc -l
100
```

接下来测试newer测试

```shell
[me@linuxbox ~]$ touch playground/timestamp
[me@linuxbox ~]$ stat playground/timestamp
File: 'playground/timestamp'
Size: 0 Blocks: 0 IO Block: 4096 regular empty file
Device: 803h/2051d Inode: 14265061 Links: 1
Access: (0644/-rw-r--r--) Uid: ( 1001/ me) Gid: ( 1001/ me)
Access: 2008-10-08 15:15:39.000000000 -0400
Modify: 2008-10-08 15:15:39.000000000 -0400
Change: 2008-10-08 15:15:39.000000000 -0400
```

使用 find 命令来更新一些操练场中的文件：

```shell
[me@linuxbox ~]$ find playground -type f -name 'file-B
```

通过把所有文件与参考文件 timestamp 做比较：

```shell
[me@linuxbox ~]$ find playground -type f -newer playground/timestamp
```

结果会显示所有的file-B。

接下来测试权限

```shell
[me@linuxbox ~]$ find playground \( -type f -not -perm 0600 \) -or \( -type d -not -perm 0700 \) | wc -l
2702
```

可以给这个命令 添加行为，对实战场中的文件和目录应用新的权限。

```shell
[me@linuxbox ~]$ find playground \( -type f -not -perm 0600 -exec chmod 0600 '{}' ';' \) -or \( -type d -not -perm 0711 -exec chmod 0700 '{}' ';' \)
```

再次执行上次的权限find

结果为0，说明权限已经被更改了。

### 18. 归档和备份

文件压缩程序：

> - gzip – 压缩或者展开文件
> - bzip2 – 块排序文件压缩器

归档程序：

> - tar – 磁带打包工具
> - zip – 打包和压缩文件

文件同步程序：

> - rsync – 同步远端文件和目录

##### 压缩文件

###### gzip

用法

```shell
[me@linuxbox ~]$ gzip foo.txt
[me@linuxbox ~]$ ls -l foo.*
-rw-r--r-- 1 me     me 3230 2008-10-14 07:15 foo.txt.gz
[me@linuxbox ~]$ gunzip foo.txt.gz
[me@linuxbox ~]$ ls -l foo.*
-rw-r--r-- 1 me     me 15738 2008-10-14 07:15 foo.txt
```

gzip 选项

| 选项    | 说明                                                         |
| :------ | :----------------------------------------------------------- |
| -c      | 把输出写入到标准输出，并且保留原始文件。也有可能用--stdout 和--to-stdout 选项来指定。 |
| -d      | 解压缩。正如 gunzip 命令一样。也可以用--decompress 或者--uncompress 选项来指定. |
| -f      | 强制压缩，即使原始文件的压缩文件已经存在了，也要执行。也可以用--force 选项来指定。 |
| -h      | 显示用法信息。也可用--help 选项来指定。                      |
| -l      | 列出每个被压缩文件的压缩数据。也可用--list 选项。            |
| -r      | 若命令的一个或多个参数是目录，则递归地压缩目录中的文件。也可用--recursive 选项来指定。 |
| -t      | 测试压缩文件的完整性。也可用--test 选项来指定。              |
| -v      | 显示压缩过程中的信息。也可用--verbose 选项来指定。           |
| -number | 设置压缩指数。number 是一个在1（最快，最小压缩）到9（最慢，最大压缩）之间的整数。 数值1和9也可以各自用--fast 和--best 选项来表示。默认值是整数6。 |

对应于 gzip 还有一个程序，叫做 **zcat，它等同于带有-c 选项的 gunzip 命令**。 它可以被用来如 cat 命令作用于 gzip 压缩文件：

```shell
[me@linuxbox ~]$ zcat foo.txt.gz | less
```

###### bzip2

与 gzip 程序相似，但是使用了不同的压缩算法， 舍弃了压缩速度，而实现了更高的压缩级别。在大多数情况下，它的工作模式等同于 gzip。 由 bzip2 压缩的文件，用扩展名 .bz2 来表示：

```shell
[me@linuxbox ~]$ ls -l /etc > foo.txt
[me@linuxbox ~]$ ls -l foo.txt
-rw-r--r-- 1 me     me      15738 2008-10-17 13:51 foo.txt
[me@linuxbox ~]$ bzip2 foo.txt
[me@linuxbox ~]$ ls -l foo.txt.bz2
-rw-r--r-- 1 me     me      2792 2008-10-17 13:51 foo.txt.bz2
[me@linuxbox ~]$ bunzip2 foo.txt.bz2
```

##### 归档文件

一个常见的，与文件压缩结合一块使用的文件管理任务是归档。**归档就是收集许多文件，并把它们 捆绑成一个大文件的过程。**归档经常作为系统备份的一部分来使用。当把旧数据从一个系统移到某 种类型的长期存储设备中时，也会用到归档程序。

###### tar

```shell
tar mode[options] pathname...
```

这里的 mode 是指以下**操作模式**（这里只展示了一部分，查看 tar 的手册来得到完整列表）之一：

表19-2: tar 模式

| 模式 | 说明                               |
| :--- | :--------------------------------- |
| c    | 为文件和／或目录列表创建归档文件。 |
| x    | 抽取归档文件。                     |
| r    | 追加具体的路径到归档文件的末尾。   |
| t    | 列出归档文件的内容。               |

```shell
[me@linuxbox ~]$ tar cf playground.tar playground
```

模式 c 和选项 f，其被用来指定这个 tar 包的名字，模式和选项可以写在一起，而且不 需要开头的短横线。

列出归档文件的内容，我们可以这样做：

```shell
[me@linuxbox ~]$ tar tf playground.tar
```

为了得到更详细的列表信息，我们可以添加选项 v：

```shell
[me@linuxbox ~]$ tar tvf playground.tar
```

现在，抽取 tar 包 playground 到一个新位置。我们先创建一个名为 foo 的新目录，更改目录， 然后抽取 tar 包中的文件：

```shell
[me@linuxbox ~]$ mkdir foo
[me@linuxbox ~]$ cd foo
[me@linuxbox ~]$ tar xf ../playground.tar
[me@linuxbox ~]$ ls
playground
```

tar 命令也可以利用标准输出和输入。这里是一个完整的例子:

```shell
[me@linuxbox foo]$ cd
[me@linuxbox ~]$ find playground -name 'file-A' | tar cf - --files-from=-
   | gzip > playground.tgz
```

在这个例子里面，我们使用 find 程序产生了一个匹配文件列表，然后把它们管道到 tar 命令中。 如果指定了文件名“-”，则其被看作是标准输入或输出，正是所需（顺便说一下，**使用“-”来表示 标准输入／输出的惯例，也被大量的其它程序使用**）。这个 --file-from 选项（也可以用 -T 来指定） 导致 tar 命令从一个文件而不是命令行来读入它的路径名列表。最后，这个由 tar 命令产生的归档 文件被管道到 gzip 命令中，然后创建了压缩归档文件 playground.tgz。此 .tgz 扩展名是命名 由 gzip 压缩的 tar 文件的常规扩展名。有时候也会使用 .tar.gz 这个扩展名。

虽然我们使用 gzip 程序来制作我们的压缩归档文件，但是**现在的 GUN 版本的 tar 命令 ，gzip 和 bzip2 压缩两者都直接支持**，各自使用 z 和 j 选项。

###### zip

 **zip 程序既是压缩工具，也是一个打包工具**。这程序使用的文件格式，Windows 用户比较熟悉， 因为它读取和写入.zip 文件。然而，在 Linux 中 gzip 是主要的压缩程序，而 bzip2则位居第二。

在 zip 命令最基本的使用中，可以这样唤醒 zip 命令：

```shell
zip options zipfile file...
```

例如，制作一个 playground 的 zip 版本的文件包，这样做：

```shell
[me@linuxbox ~]$ zip -r playground.zip playground
```

除非我们包含-r 选项，要不然只有 playground 目录（没有任何它的内容）被存储。虽然会自动添加 .zip 扩展名，但为了清晰起见，我们还是包含文件扩展名。

使用 **unzip** 程序，来直接抽取一个 zip 文件的内容。

```
[me@linuxbox ~]$ cd foo
[me@linuxbox foo]$ unzip ../playground.zip
```

对于 zip 命令（与 tar 命令相反）要注意一点，就是**如果指定了一个已经存在的文件包，其被更新 而不是被替代**。

这些程序的主要用途是为了和 Windows 系统交换文件， 而不是在 Linux 系统中执行压缩和打包操作，tar 和 gzip 程序在 Linux 系统中更受欢迎。

##### 同步文件和目录

程序能同步本地与远端的目录，通过使用 rsync 远端更新协议，此协议 允许 rsync 快速地检测两个目录的差异，执行最小量的复制来达到目录间的同步。比起其它种类的复制程序， 这就使 rsync 命令非常快速和高效。

rsync 被这样唤醒：

```shell
rsync options source destination
```

这里 source 和 destination 是下列选项之一：

- 一个本地文件或目录
- 一个远端文件或目录，以[user@]host:path 的形式存在
- 一个远端 rsync 服务器，由 rsync://[user@]host[:port]/path 指定

下一步，我们将同步 playground 目录和它在 foo 目录中相对应的副本

```shell
[me@linuxbox ~]$ rsync -av playground foo
```

我们包括了-a 选项（递归和保护文件属性）和-v 选项（冗余输出）， 来在 foo 目录中制作一个 playground 目录的镜像。当这个命令执行的时候， 我们将会看到一系列的文件和目录被复制。

把下列语句添加到.bashrc 文件中， 来实现备份到外部驱动器：

```shell
alias backup='sudo rsync -av --delete /etc /home /usr/local  /media/BigDisk/backup'
```

现在我们所做的事情就是连接外部驱动器，然后运行 backup 命令来完成备份。

##### 在网络间使用 rsync 命令

假定远程系统中有一个名为/backup 的目录， 其用来存放我们传送的文件，我们这样做：

```shell
[me@linuxbox ~]$ sudo rsync -av --delete --rsh=ssh /etc /home /usr/local remote-sys:/backup
```

我们对命令做了两处修改，来方便网络间文件复制。首先，我们添加了--rsh=ssh 选项，其指示 rsync 使用 ssh 程序作为它的远程 shell。以这种方式，我们就能够使用一个 ssh 加密通道，把数据 安全地传送到远程主机中。其次，通过在目标路径名前加上远端主机的名字（在这种情况下， 远端主机名为 remote-sys），来指定远端主机。

rsync 可以被用来在网络间同步文件的第二种方式是通过使用 rsync 服务器。

我们可以使用本地 rsync 程序和它们的 rsync 服务器来镜像它。rsync 可以被配置为一个 守护进程，监听即将到来的同步请求。这样做经常是为了允许一个远程系统的镜像。

```shell
[me@linuxbox ~]$ mkdir fedora-devel
[me@linuxbox ~]$ rsync -av -delete rsync://rsync.gtlib.gatech.edu/fedora-linux-
 core/development/i386/os fedora-devel
```

在这个例子里，我们使用了远端 rsync 服务器的 URI，其由协议（rsync://），远端主机名 （[rsync.gtlib.gatech.edu](http://rsync.gtlib.gatech.edu/)），和软件仓库的路径名组成。

### 19. 文本处理

- cat – 连接文件并且打印到标准输出
- sort – 给文本行排序
- uniq – 报告或者省略重复行
- cut – 从每行中删除文本区域
- paste – 合并文件文本行
- join – 基于某个共享字段来联合两个文件的文本行
- comm – 逐行比较两个有序的文件
- diff – 逐行比较文件
- patch – 给原始文件打补丁
- tr – 翻译或删除字符
- sed – 用于筛选和转换文本的流编辑器
- aspell – 交互式拼写检查器

#### 文本应用程序

##### cat

使用带有-A 选项的 cat 命令来显示这个文本：

```shell
[me@linuxbox ~]$ cat -A foo.txt
^IThe quick brown fox jumped over the lazy dog.       $
[me@linuxbox ~]$
```

在输出结果中我们看到，这个 tab 字符在我们的文本中由^I 字符来表示。这是一种常见的表示方法，意思是 “Control-I”，结果证明，它和 tab 字符是一样的。我们也看到一个$字符出现在文本行真正的结尾处， 表明我们的文本包含末尾的空格。

cat 程序也包含用来修改文本的选项。最著名的两个选项是-n：其给文本行添加行号和-s：禁止输出多个空白行。我们这样来说明：

```shell
[me@linuxbox ~]$ cat > foo.txt
The quick brown fox

jumped over the lazy dog.
[me@linuxbox ~]$ cat -ns foo.txt
1   The quick brown fox
2
3   jumped over the lazy dog.
[me@linuxbox ~]$
```

在这个例子里，我们创建了一个测试文件 foo.txt 的新版本，其包含两行文本，由两个空白行分开。 经由带有-ns 选项的 cat 程序处理之后，多余的空白行被删除，并且对保留的文本行进行编号。 然而这并不是多个进程在操作这个文本，只有一个进程。

##### sort

这个 sort 程序对标准输入的内容，或命令行中指定的一个或多个文件进行排序，然后把排序 结果发送到标准输出。使用与 cat 命令相同的技巧，我们能够演示如何用 sort 程序来处理标准输入：

```shell
[me@linuxbox ~]$ sort > foo.txt
c
b
a
[me@linuxbox ~]$ cat foo.txt
a
b
c
```

常见的 sort 程序选项

| 选项 | 长选项                  | 描述                                                         |
| :--- | :---------------------- | :----------------------------------------------------------- |
| -b   | --ignore-leading-blanks | 默认情况下，对整行进行排序，从每行的第一个字符开始。这个选项导致 sort 程序忽略 每行开头的空格，从第一个非空白字符开始排序。 |
| -f   | --ignore-case           | 让排序不区分大小写。                                         |
| -n   | --numeric-sort          | 基于字符串的长度来排序。使用此选项允许根据数字值执行排序，而不是字母值。 |
| -r   | --reverse               | 按相反顺序排序。结果按照降序排列，而不是升序。               |
| -k   | --key=field1[,field2]   | 对从 field1到 field2之间的字符排序，而不是整个文本行。看下面的讨论。 |
| -m   | --merge                 | 把每个参数看作是一个预先排好序的文件。把多个文件合并成一个排好序的文件，而没有执行额外的排序。 |
| -o   | --output=file           | 把排好序的输出结果发送到文件，而不是标准输出。               |
| -t   | --field-separator=char  | 定义域分隔字符。默认情况下，域由空格或制表符分隔。           |

例子：

```shell
[me@linuxbox ~]$ ls -l /usr/bin | sort -nr -k 5 | head
-rwxr-xr-x 1 root   root   8234216  2008-04-0717:42 inkscape
-rwxr-xr-x 1 root   root   8222692  2008-04-07 17:42 inkview
...
```

##### uniq

与 sort 程序相比，这个 uniq 程序是个轻量级程序。uniq 执行一个看似琐碎的认为。当给定一个 **排好序的文件**（包括标准输出），uniq 会**删除任意重复行**，并且把结果发送到标准输出。 它常常和 sort 程序一块使用，来清理重复的输出。

 常用的 uniq 选项

| 选项 | 说明                                                         |
| :--- | :----------------------------------------------------------- |
| -c   | 输出所有的重复行，并且每行开头显示重复的次数。               |
| -d   | 只输出重复行，而不是特有的文本行。                           |
| -f n | 忽略每行开头的 n 个字段，字段之间由空格分隔，正如 sort 程序中的空格分隔符；然而， 不同于 sort 程序，uniq 没有选项来设置备用的字段分隔符。 |
| -i   | 在比较文本行的时候忽略大小写。                               |
| -s n | 跳过（忽略）每行开头的 n 个字符。                            |
| -u   | 只是输出独有的文本行。这是默认的。                           |

例子：这里我们看到 uniq 被用来报告文本文件中重复行的次数，使用这个-c 选项：

```shell
[me@linuxbox ~]$ sort foo.txt | uniq -c
        2 a
        2 b
        2 c
```

#### 切片和切块

##### cut

cut 程序被用来从文本行中抽取文本，并把其输出到标准输出。

cut 程序选择项

| 选项          | 说明                                                         |
| :------------ | :----------------------------------------------------------- |
| -c char_list  | 从文本行中抽取由 char_list 定义的文本。这个列表可能由一个或多个逗号 分隔开的数值区间组成。 |
| -f field_list | 从文本行中抽取一个或多个由 field_list 定义的字段。这个列表可能 包括一个或多个字段，或由逗号分隔开的字段区间。 |
| -d delim_char | 当指定-f 选项之后，使用 delim_char 做为字段分隔符。默认情况下， 字段之间必须由单个 tab 字符分隔开。 |
| --complement  | 抽取整个文本行，除了那些由-c 和／或-f 选项指定的文本。       |

抽取字符：

```shell
[me@linuxbox ~]$ cut -f 3 distros.txt | cut -c 7-10
2006
2008
2007
2006
2007
2006
2008
2006
2008
2006
```

##### paste

paste 命令的功能正好与 cut 相反。它会**添加一个或多个文本列到文件中**，而不是从文件中抽取文本列。 它通过读取多个文件，然后把每个文件中的字段整合成单个文本流，输入到标准输出。

例子：

```shell
[me@linuxbox ~]$ paste distros-dates.txt distros-versions.txt
11/25/2008	Fedora     10
10/30/2008	Ubuntu     8.10
06/19/2008	SUSE       11.0
05/13/2008	Fedora     9
04/24/2008	Ubuntu     8.04
11/08/2007	Fedora     8
10/18/2007	Ubuntu     7.10
10/04/2007	SUSE       10.3
05/31/2007	Fedora     7
04/19/2007	Ubuntu     7.04
```

##### join

例子：

```shell
[me@linuxbox ~]$ join distros-key-names.txt distros-key-vernums.txt | head
11/25/2008 Fedora 10
10/30/2008 Ubuntu 8.10
06/19/2008 SUSE 11.0
05/13/2008 Fedora 9
04/24/2008 Ubuntu 8.04
11/08/2007 Fedora 8
10/18/2007 Ubuntu 7.10
10/04/2007 SUSE 10.3
05/31/2007 Fedora 7
04/19/2007 Ubuntu 7.04
```

#### 比较文本

##### comm

 comm 程序会比较两个文本文件，并且会显示每个文件特有的文本行和共有的文本行。 为了说明问题，通过使用 cat 命令，我们将会创建两个内容几乎相同的文本文件：

```shell
[me@linuxbox ~]$ cat > file1.txt
a
b
c
d
[me@linuxbox ~]$ cat > file2.txt
b
c
d
e
```

下一步，我们将使用 comm 命令来比较这两个文件：

```shell
[me@linuxbox ~]$ comm file1.txt file2.txt
a
        b
        c
        d
    e
```

comm 命令产生了三列输出。第一列包含第一个文件独有的文本行；第二列， 文本行是第二列独有的；第三列包含两个文件共有的文本行。comm 支持 -n 形式的选项，这里 n 代表 1，2 或 3。这些选项使用的时候，指定了要**隐藏**的列。

##### diff

类似于 comm 程序，diff 程序被用来监测文件之间的差异。

使用 diff 程序，来查看我们之前的文件实例：

```shell
[me@linuxbox ~]$ diff file1.txt file2.txt
1d0
< a
4a4
> e
```

diff 更改命令

| 改变  | 说明                                                         |
| :---- | :----------------------------------------------------------- |
| r1ar2 | 把第二个文件中位置 r2 处的文件行添加到第一个文件中的 r1 处。 |
| r1cr2 | 用第二个文件中位置 r2 处的文本行更改（替代）位置 r1 处的文本行。 |
| r1dr2 | 删除第一个文件中位置 r1 处的文本行，这些文本行将会出现在第二个文件中位置 r2 处。 |

最流行的两种格式是**上下文模式**和**统一模式**。

当使用上下文模式（带上 -c 选项），我们将看到这些：

```shell
[me@linuxbox ~]$ diff -c file1.txt file2.txt
*** file1.txt    2008-12-23 06:40:13.000000000 -0500
--- file2.txt   2008-12-23 06:40:34.000000000 -0500
***************
*** 1,4 ****
- a
  b
  c
  d
--- 1,4 ----
  b
  c
  d
  + e
```

diff 上下文模式更改指示符

| 指示符 | 意思                                                         |
| :----- | :----------------------------------------------------------- |
| blank  | 上下文显示行。它并不表示两个文件之间的差异。                 |
| -      | 删除行。这一行将会出现在第一个文件中，而不是第二个文件内。   |
| +      | 添加行。这一行将会出现在第二个文件内，而不是第一个文件中。   |
| !      | 更改行。将会显示某个文本行的两个版本，每个版本会出现在更改组的各自部分。 |

统一模式相似于上下文模式，但是更加简洁。通过 -u 选项来指定它：

```shell
[me@linuxbox ~]$ diff -u file1.txt file2.txt
--- file1.txt 2008-12-23 06:40:13.000000000 -0500
+++ file2.txt 2008-12-23 06:40:34.000000000 -0500
@@ -1,4 +1,4 @@
-a
 b
 c
 d
+e
```

上下文模式和统一模式之间最显著的差异就是重复上下文的消除，这就使得统一模式的输出结果要比上下文 模式的输出结果简短。在我们上述实例中，我们看到类似于上下文模式中的文件时间戳，其紧紧跟随字符串 @@ -1,4 +1,4 @@。这行字符串表示了在更改组中描述的第一个文件中的文本行和第二个文件中的文本行。 这行字符串之后就是文本行本身，与三行默认的上下文。每行以可能的三个字符中的一个开头：

diff 统一模式更改指示符

| 字符 | 意思                       |
| :--- | :------------------------- |
| 空格 | 两个文件都包含这一行。     |
| -    | 在第一个文件中删除这一行。 |
| +    | 添加这一行到第一个文件中。 |

##### patch

配合diff使用

例子：

```shell
[me@linuxbox ~]$ diff -Naur file1.txt file2.txt > patchfile.txt
[me@linuxbox ~]$ patch < patchfile.txt
patching file file1.txt
[me@linuxbox ~]$ cat file1.txt
b
c
d
e
```

#### 运行时编辑

##### tr

 tr 程序被用来更改字符。我们可以把它看作是一种基于字符的查找和替换操作。 换字是一种把字符从一个字母转换为另一个字母的过程。例如，把小写字母转换成大写字母就是 换字。我们可以通过 tr 命令来执行这样的转换，如下所示：

```shell
[me@linuxbox ~]$ echo "lowercase letters" | tr a-z A-Z
LOWERCASE LETTERS
```

字符集可以用三种方式来表示：

1. 一个枚举列表。例如， ABCDEFGHIJKLMNOPQRSTUVWXYZ
2. 一个字符域。例如，A-Z 。注意这种方法有时候面临与其它命令相同的问题，归因于 语系的排序规则，因此应该谨慎使用。
3. POSIX 字符类。例如，[:upper:]

tr 命令能允许字符从输入流中简单地被删除。在之前的章节中，我们讨论了转换 MS-DOS 文本文件为 Unix 风格文本的问题。为了执行这个转换，每行末尾的回车符需要被删除。 这个可以通过 tr 命令来执行，如下所示：

```shell
tr -d '\r' < dos_file > unix_file
```

这里的 dos_file 是需要被转换的文件，unix_file 是转换后的结果。这种形式的命令使用转义序列 \r 来代表回车符。

r 也可以完成另一个技巧。使用-s 选项，tr 命令能“挤压”（删除）重复的字符实例：

```
[me@linuxbox ~]$ echo "aaabbbccc" | tr -s ab
abccc
```

这里我们有一个包含重复字符的字符串。通过给 tr 命令指定字符集“ab”，我们能够消除字符集中字母的重复实例，然而会留下不属于字符集的字符（“c”）无更改。注意**重复的字符必须是相邻的**。

##### sed

名字 sed 是 stream editor（流编辑器）的简称。

一个非常简单的 sed 实例：

```shell
[me@linuxbox ~]$ echo "front" | sed 's/front/back/'
back
```

如果省略了地址， 然后会对输入流的每一行执行编辑命令。最简单的地址形式是一个行号。我们能够添加一个地址 到我们例子中：

```shell
[me@linuxbox ~]$ echo "front" | sed '1s/front/back/'
back
```

sed 地址表示法

| 地址        | 说明                                                         |
| :---------- | :----------------------------------------------------------- |
| n           | 行号，n 是一个正整数。                                       |
| $           | 最后一行。                                                   |
| /regexp/    | 所有匹配一个 POSIX 基本正则表达式的文本行。注意正则表达式通过 斜杠字符界定。选择性地，这个正则表达式可能由一个备用字符界定，通过\cregexpc 来 指定表达式，这里 c 就是一个备用的字符。 |
| addr1,addr2 | 从 addr1 到 addr2 范围内的文本行，包含地址 addr2 在内。地址可能是上述任意 单独的地址形式。 |
| first~step  | 匹配由数字 first 代表的文本行，然后随后的每个在 step 间隔处的文本行。例如 1~2 是指每个位于偶数行号的文本行，5~5 则指第五行和之后每五行位置的文本行。 |
| addr1,+n    | 匹配地址 addr1 和随后的 n 个文本行。                         |
| addr!       | 匹配所有的文本行，除了 addr 之外，addr 可能是上述任意的地址形式。 |

sed 基本编辑命令

| 命令                  | 说明                                                         |
| :-------------------- | :----------------------------------------------------------- |
| =                     | 输出当前的行号。                                             |
| a                     | 在当前行之后追加文本。                                       |
| d                     | 删除当前行。                                                 |
| i                     | 在当前行之前插入文本。                                       |
| p                     | 打印当前行。默认情况下，sed 程序打印每一行，并且只是编辑文件中匹配 指定地址的文本行。通过指定-n 选项，这个默认的行为能够被忽略。 |
| q                     | 退出 sed，不再处理更多的文本行。如果不指定-n 选项，输出当前行。 |
| Q                     | 退出 sed，不再处理更多的文本行。                             |
| s/regexp/replacement/ | 只要找到一个 regexp 匹配项，就替换为 replacement 的内容。 replacement 可能包括特殊字符 &，其等价于由 regexp 匹配的文本。另外， replacement 可能包含序列 \1到 \9，其是 regexp 中相对应的子表达式的内容。更多信息，查看 下面 back references 部分的讨论。在 replacement 末尾的斜杠之后，可以指定一个 可选的标志，来修改 s 命令的行为。 |
| y/set1/set2           | 执行字符转写操作，通过把 set1 中的字符转变为相对应的 set2 中的字符。 注意不同于 tr 程序，sed 要求两个字符集合具有相同的长度。 |

##### aspell

aspell，一款交互式的拼写检查器。

拼写检查一个包含简单的文本文件，可以这样使用 aspell:

```shell
aspell check textfile
```

例子： aspell 在检查模式下是交互的，我们将看到像这样的一个屏幕：

```shell
The quick brown fox jimped over the laxy dog.
1)jumped                        6)wimped
2)gimped                        7)camped
3)comped                        8)humped
4)limped                        9)impede
5)pimped                        0)umped
i)Ignore                        I)Ignore all
r)Replace                       R)Replace all
a)Add                           l)Add Lower
b)Abort                         x)Exit
?
```

### 20. 格式化输出

- nl – 添加行号
- fold – 限制文件列宽
- fmt – 一个简单的文本格式转换器

##### 简单的格式化工具

###### nl - 添加行号

nl 程序是一个相当神秘的工具，用作一个简单的任务。它添加文件的行数。在它最简单的用途中，它相当于 cat -n:

```shell
[me@linuxbox ~]$ nl distros.txt | head
```

###### fold - 限制文件行宽

折叠是将文本的行限制到特定的宽的过程。像我们的其他命令，fold 接受一个或多个文件及标准输入。如果我们将 一个简单的文本流 fold，我们可以看到它工具的方式：增加的 -s 选项将让 fold 分解到最后可用的空白 字符，即会考虑单词边界。

```shell
[me@linuxbox ~]$ echo "The quick brown fox jumped over the lazy dog."
| fold -w 12 -s
The quick
brown fox
jumped over
the lazy
dog.
```

###### fmt - 一个简单的文本格式器

fmt 程序同样折叠文本，外加很多功能。它接受文本或标准输入并且在文本流上呈现照片转换。基础来说，他填补并且将文本粘帖在 一起并且保留了空白符和缩进。

### 21. 编译程序

> 那么为什么解释型程序这样流行呢？对于许多编程任务来说，原因是“足够快”，但是真正的优势是一般来说开发解释型程序 要比编译程序快速且容易。通常程序开发需要经历一个不断重复的写码，编译，测试周期。随着程序变得越来越大， 编译阶段会变得相当耗时。解释型语言删除了编译步骤，这样就加快了程序开发。

##### 编译一个 C 语言

查看该编译器是否存在：

```shell
[me@linuxbox ~]$ which gcc
/usr/bin/gcc
```

得到源码:

```shell
[me@linuxbox ~]$ mkdir src
[me@linuxbox ~]$ cd src
[me@linuxbox src]$ ftp ftp.gnu.org
Connected to ftp.gnu.org.
220 GNU FTP server ready.
Name (ftp.gnu.org:me): anonymous
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> cd gnu/diction
250 Directory successfully changed.
ftp> ls
200 PORT command successful. Consider using PASV.
150 Here comes the directory listing.
-rw-r--r-- 1 1003 65534 68940 Aug 28 1998 diction-0.7.tar.gz
-rw-r--r-- 1 1003 65534 90957 Mar 04 2002 diction-1.02.tar.gz
-rw-r--r-- 1 1003 65534 141062 Sep 17 2007 diction-1.11.tar.gz
226 Directory send OK.
ftp> get diction-1.11.tar.gz
local: diction-1.11.tar.gz remote: diction-1.11.tar.gz
200 PORT command successful. Consider using PASV.
150 Opening BINARY mode data connection for diction-1.11.tar.gz
(141062 bytes).
226 File send OK.
141062 bytes received in 0.16 secs (847.4 kB/s)
ftp> bye
221 Goodbye.
[me@linuxbox src]$ ls
diction-1.11.tar.gz
```

###### 检查源码树

在源码树中，我们看到大量的文件。属于 GNU 项目的程序，还有其它许多程序都会，提供文档文件 README，INSTALL，NEWS，和 COPYING。

这些文件包含了程序描述，如何建立和安装它的信息，还有它许可条款。

```c
#include <regex.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
```

这些也涉及到头文件，但是这些头文件居住在当前源码树的外面。它们由操作系统供给，来支持每个程序的编译。 如果我们看一下 /usr/include 目录，能看到它们：

```shell
[me@linuxbox diction-1.11]$ ls /usr/include
```

###### 构建程序

大多数程序通过一个简单的，两个命令的序列构建：

```shell
./configure
make
```

这个 configure 程序是一个 shell 脚本，由源码树提供。它的工作是分析程序建立环境。大多数源码会设计为可移植的。 也就是说，它被设计成，能建立在多于一个的类 Unix 系统中。但是为了做到这一点，在建立程序期间，为了适应系统之间的差异， 源码可能需要经过轻微的调整。configure 也会检查是否安装了必要的外部工具和组件。

```
[me@linuxbox diction-1.11]$ ./configure
```

configure 将会输出许多信息，随着它测试和配置整个构建过程。当结束后，输出结果看起来像这样：

```
checking libintl.h presence... yes
checking for libintl.h... yes
checking for library containing gettext... none required
configure: creating ./config.status
config.status: creating Makefile
config.status: creating diction.1
config.status: creating diction.texi
config.status: creating diction.spec
config.status: creating style.1
config.status: creating test/rundiction
config.status: creating config.h
[me@linuxbox diction-1.11]$
```

这里最重要的事情是没有错误信息。如果有错误信息，整个配置过程失败，然后程序不能构建直到修正了错误。

我们看到在我们的源码目录中 configure 命令创建了几个新文件。最重要一个是 Makefile。Makefile 是一个配置文件， 指示 make 程序究竟如何构建程序。没有它，make 程序就不能运行。Makefile 是一个普通文本文件，所以我们能查看它：

```shell
[me@linuxbox diction-1.11]$ less Makefile
```

这个 make 程序把一个 makefile 文件作为输入（通常命名为 Makefile），makefile 文件 描述了包括最终完成的程序的各组件之间的关系和依赖性。

makefile 文件的第一部分定义了变量，这些变量在该 makefile 后续章节中会被替换掉。例如我们看看这一行代码：

```makefile
CC=                 gcc
```

其定义了所用的 C 编译器是 gcc。文件后面部分，我们看到一个使用该变量的实例：

```makefile
diction:        diction.o sentence.o misc.o getopt.o getopt1.o
                $(CC) -o $@ $(LDFLAGS) diction.o sentence.o misc.o \
                getopt.o getopt1.o $(LIBS)
```

这里完成了一个替换操作，在程序运行时，$(CC) 的值会被替换成 gcc。大多数 makefile 文件由行组成，每行定义一个目标文件， 在这种情况下，目标文件是指可执行文件 diction，还有目标文件所依赖的文件。剩下的行描述了从目标文件的依赖组件中 创建目标文件所需的命令。在这个例子中，我们看到可执行文件 diction（最终的成品之一）依赖于文件 diction.o，sentence.o，misc.o，getopt.o，和 getopt1.o都存在。在 makefile 文件后面部分，我们看到 diction 文件所依赖的每一个文件做为目标文件的定义：

```makefile
diction.o:       diction.c config.h getopt.h misc.h sentence.h
getopt.o:        getopt.c getopt.h getopt_int.h
getopt1.o:       getopt1.c getopt.h getopt_int.h
misc.o:          misc.c config.h misc.h
sentence.o:      sentence.c config.h misc.h sentence.h
style.o:         style.c config.h getopt.h misc.h sentence.h
```

然而，我们不会看到针对它们的任何命令。这个由一个通用目标解决，在文件的前面，描述了这个命令，用来把任意的 .c 文件编译成 .o 文件：

```makefile
.c.o:
            $(CC) -c $(CPPFLAGS) $(CFLAGS) $<
```

这些看起来非常复杂。为什么不简单地列出所有的步骤，编译完成每一部分？一会儿就知道答案了。同时， 让我们运行 make 命令并构建我们的程序：

```shell
[me@linuxbox diction-1.11]$ make
```

这个 make 程序将会运行，使用 Makefile 文件的内容来指导它的行为。它会产生很多信息。

当 make 程序运行结束后，现在我们将看到所有的目标文件出现在我们的目录中。

```shell
[me@linuxbox diction-1.11]$ ls
config.guess  de.po             en              en_GB           sentence.c
config.h      diction           en_GB.mo        en_GB.po        sentence.h
config.h.in   diction.1         getopt1.c       getopt1.o       sentence.o
config.log    diction.1.in      getopt.c        getopt.h        style
config.status diction.c         getopt_int.h    getopt.o        style.1
config.sub    diction.o         INSTALL         install-sh      style.1.in
configure     diction.pot       Makefile        Makefile.in     style.c
configure.in  diction.spec      misc.c          misc.h          style.o
COPYING       diction.spec.in   misc.o          NEWS            test
de            diction.texi      nl              nl.mo
de.mo         diction.texi.i    nl.po           README
```

在这些文件之中，我们看到 diction 和 style，我们开始要构建的程序。恭喜一切正常！我们刚才源码编译了 我们的第一个程序。但是出于好奇，让我们再运行一次 make 程序：

```shell
[me@linuxbox diction-1.11]$ make
make: Nothing to be done for `all'.
```

它只是产生这样一条奇怪的信息。怎么了？为什么它没有重新构建程序呢？啊，这就是 make 奇妙之处了。make 只是构建 需要构建的部分，而不是简单地重新构建所有的内容。由于所有的目标文件都存在，make 确定没有任何事情需要做。 我们可以证明这一点，通过删除一个目标文件，然后再次运行 make 程序，看看它做些什么。让我们去掉一个中间目标文件：

```shell
[me@linuxbox diction-1.11]$ rm getopt.o
[me@linuxbox diction-1.11]$ make
```

我们看到 make 重新构建了 getopt.o 文件，并重新链接了 diction 和 style 程序，因为它们依赖于丢失的模块。 这种行为也指出了 make 程序的另一个重要特征：它保持目标文件是最新的。make 坚持目标文件要新于它们的依赖文件。 这个非常有意义，做为一名程序员，经常会更新一点儿源码，然后使用 make 来构建一个新版本的成品。make 确保 基于更新的代码构建了需要构建的内容。如果我们使用 touch 程序，来“更新”其中一个源码文件，我们看到发生了这样的事情：

```shell
[me@linuxboxdiction-1.11]$ ls -l diction getopt.c
-rwxr-xr-x 1 me me 37164 2009-03-05 06:14 diction
-rw-r--r-- 1 me me 33125 2007-03-30 17:45 getopt.c
[me@linuxboxdiction-1.11]$ touch getopt.c
[me@linuxboxdiction-1.11]$ ls -l diction getopt.c
-rwxr-xr-x 1 me me 37164 2009-03-05 06:14 diction
-rw-r--r-- 1 me me 33125 2009-03-05 06:23 getopt.c
[me@linuxbox diction-1.11]$ make
```

运行 make 之后，我们看到目标文件已经更新于它的依赖文件：

```shell
[me@linuxbox diction-1.11]$ ls -l diction getopt.c
-rwxr-xr-x 1 me me 37164 2009-03-05 06:24 diction
-rw-r--r-- 1 me me 33125 2009-03-05 06:23 getopt.c
```

make 程序这种智能地只构建所需要构建的内容的特性，对程序来说，是巨大的福利。虽然在我们的小项目中，节省的时间可能 不是非常明显，在庞大的工程中，它具有非常重大的意义。记住，Linux 内核（一个经历着不断修改和改进的程序）包含了几百万行代码。

###### 安装程序

打包良好的源码经常包括一个特别的 make 目标文件，叫做 install。这个目标文件将在系统目录中安装最终的产品，以供使用。 通常，这个目录是 /usr/local/bin，为在本地所构建软件的传统安装位置。然而，通常普通用户不能写入该目录，所以我们必须变成超级用户， 来执行安装操作：

```shell
[me@linuxbox diction-1.11]$ sudo make install
After we perform the installation, we can check that the program is ready to go:
[me@linuxbox diction-1.11]$ which diction
/usr/local/bin/diction
[me@linuxbox diction-1.11]$ man diction
And there we have it!
```

### 22. 编写第一个shell脚本

##### 脚本文件格式

```bash
#!/bin/bash
# This is our first script.
echo 'Hello World!'
```

这个#!字符序列是一种特殊的结构叫做 shebang。 这个 shebang 被用来告诉操作系统将执行此脚本所用的解释器的名字。每个 shell 脚本都应该把这一文本行作为它的第一行。

##### 可执行权限

```shell
[me@linuxbox ~]$ ls -l hello_world
-rw-r--r-- 1  me    me      63  2009-03-07 10:10 hello_world
[me@linuxbox ~]$ chmod 755 hello_world
[me@linuxbox ~]$ ls -l hello_world
-rwxr-xr-x 1  me    me      63  2009-03-07 10:10 hello_world
```

或者使用

```shell
[me@linuxbox ~]$ chmod +x hello_world 
```

##### 脚本文件位置

```shell
[me@linuxbox ~]$ ./hello_world
Hello World!
```

在我们的.bashrc 文件中包含下面 这一行文本：

```bash
export PATH=~/bin:"$PATH"
```

当做了这个修改之后，它会在每个新的终端会话中生效。为了把这个修改应用到当前的终端会话中， 我们必须让 shell 重新读取这个 .bashrc 文件。这可以通过`source .bashrc `文件来完成：

```shell
[me@linuxbox ~]$ . .bashrc
```

这个点（.）命令是 source 命令的同义词，一个 shell 内部命令，用来**读取一个指定的 shell 命令文件**， 并把它看作是从键盘中输入的一样。

##### 脚本文件的好去处

这个 ~/bin 目录是存放为个人所用脚本的好地方。如果我们编写了一个脚本，系统中的每个用户都可以使用它， 那么这个脚本的传统位置是 /usr/local/bin。系统管理员使用的脚本经常放到 /usr/local/sbin 目录下。 大多数情况下，本地支持的软件，不管是脚本还是编译过的程序，都应该放到 /usr/local 目录下， 而不是在 **/bin 或 /usr/bin 目录下。这些目录都是由 Linux 文件系统层次结构标准指定，只包含由 Linux 发行商所提供和维护的文件**。(yum 安装的在/usr/bin下，自己写的/usr/local/bin)

##### vim 的简单配置

为书写脚本配置 vim

这个 vim 文本编辑器有许多许多的配置设置。有几个常见的选项能够有助于脚本书写：

:syntax on

打开语法高亮。通过这个设置，当查看脚本的时候，不同的 shell 语法元素会以不同的颜色 显示。这对于识别某些编程错误很有帮助。并且它看起来也很酷。注意为了这个功能起作用，你 必须安装了一个完整的 vim 版本，并且你编辑的文件必须有一个 shebang，来说明这个文件是 一个 shell 脚本。如果对于上面的命令，你遇到了困难，试试 :set syntax=sh。

:set hlsearch

打开这个选项是为了高亮查找结果。比如说我们查找单词“echo”。通过设置这个选项，这个 单词的每个实例会高亮显示。

:set tabstop=4

设置一个 tab 字符所占据的列数。默认是8列。把这个值设置为4（一种常见做法）， 从而让长文本行更容易适应屏幕。

:set autoindent

打开 “auto indent” 功能。这导致 vim 能对新的文本行缩进与刚输入的文本行相同的列数。 对于许多编程结构来说，这就加速了输入。停止缩进，输入 Ctrl-d。

通过把这些命令（没有开头的冒号字符）添加到你的 **/etc/vimrc** 文件中，这些改动会永久生效。

### 23. 启动一个项目

关于变量名的规则：

1. 变量名可由字母数字字符（字母和数字）和下划线字符组成。
2. 变量名的第一个字符必须是一个字母或一个下划线。
3. 变量名中不允许出现空格和标点符号。

一个常用惯例是指定大写字母来表示常量，小写字母表示真正的变量。

在赋值过程中，变量名，等号和变量值之间必须没有空格。那么，这些值由什么组成呢？ 可以展开成字符串的任意值：

```bash
a=z                     # Assign the string "z" to variable a.
b="a string"            # Embedded spaces must be within quotes.
c="a string and $b"     # Other expansions such as variables can be
                        # expanded into the assignment.

d=$(ls -l foo.txt)      # Results of a command.
e=$((5 * 7))            # Arithmetic expansion.
f="\t\ta string\n"      # Escape sequences such as tab
```

可以在同一行中对多个变量赋值：

```bash
a=5 b="a string"
```

通过添加**花括号**，shell 不再把末尾的1解释为变量名的一部分。

```shell
[me@linuxbox ~]$ mv $filename ${filename}1
```

##### Here Documents

 here document 或者 here script。一个 here document 是另外一种 I/O 重定向形式，我们 在脚本文件中嵌入正文文本，然后把它发送给一个命令的标准输入。它这样工作：

```
command << token
text
token
```

这里的 command 是一个可以接受标准输入的命令名，token 是一个用来指示嵌入文本结束的字符串。 我们将修改我们的脚本，来使用一个 here document:

```bash
#!/bin/bash
# Program to output a system information page
TITLE="System Information Report For $HOSTNAME"
CURRENT_TIME=$(date +"%x %r %Z")
TIME_STAMP="Generated $CURRENT_TIME, by $USER"
cat << _EOF_
<HTML>
         <HEAD>
                <TITLE>$TITLE</TITLE>
         </HEAD>
         <BODY>
                <H1>$TITLE</H1>
                <P>$TIME_STAMP</P>
         </BODY>
</HTML>
_EOF_
```

取代 echo 命令，现在我们的脚本使用 cat 命令和一个 here document。这个字符串_EOF_（意思是“文件结尾”， 一个常见用法）被选作为 token，并标志着嵌入文本的结尾。注意这个 token 必须在一行中单独出现，并且文本行中 没有末尾的空格。

那么使用一个 here document 的优点是什么呢？它很大程度上和 echo 一样，除了**默认情况下，here documents 中的单引号和双引号会失去它们在 shell 中的特殊含义**。这里有一个命令中的例子：

```shell
[me@linuxbox ~]$ foo="some text"
[me@linuxbox ~]$ cat << _EOF_
> $foo
> "$foo"
> '$foo'
> \$foo
> _EOF_
some text
"some text"
'some text'
$foo
```

正如我们所见到的，shell 根本没有注意到引号。它把它们看作是普通的字符。这就允许我们 在一个 here document 中可以随意的嵌入引号。对于我们的报告程序来说，这将是非常方便的。

Here documents 可以和任意能接受标准输入的命令一块使用。

如果我们把重定向操作符从 “<<” 改为 “<<-”，shell 会忽略在此 here document 中开头的 tab 字符。 这就能缩进一个 here document.

### 24. 自顶而下设计

##### Shell 函数

shell 函数是位于其它脚本中的“微脚本”，作为自主程序。Shell 函数有两种语法形式：

```bash
function name {
    commands
    return
}
and
name () {
    commands
    return
}
```

这里的 name 是函数名，commands 是一系列包含在函数中的命令。

两种形式是等价的，可以交替使用。下面我们将查看一个说明 shell 函数使用方法的脚本：

```bash
1     #!/bin/bash
2
3     # Shell function demo
4
5     function funct {
6       echo "Step 2"
7       return
8     }
9
10     # Main program starts here
11
12     echo "Step 1"
13     funct
14     echo "Step 3"
```

##### 局部变量

通过在变量名之前加上单词 **local**，来定义局部变量。这就创建了一个只对其所在的 shell 函数起作用的变量。在这个 shell 函数之外，这个变量不再存在。

例子：

```bash
#!/bin/bash
# local-vars: script to demonstrate local variables
foo=0 # global variable foo
funct_1 () {
    local foo  # variable foo local to funct_1
    foo=1
    echo "funct_1: foo = $foo"
}
funct_2 () {
    local foo  # variable foo local to funct_2
    foo=2
    echo "funct_2: foo = $foo"
}
echo "global:  foo = $foo"
funct_1
echo "global: foo = $foo"
funct_2
echo "global: foo = $foo"
```

运行结果：

```shell
[me@linuxbox ~]$ local-vars
global:  foo = 0
funct_1: foo = 1
global:  foo = 0
funct_2: foo = 2
global:  foo = 0
```

### 25. 流程控制 if 分支结构

##### 退出状态

当命令执行完毕后，命令（包括我们编写的脚本和 shell 函数）会给系统发送一个值，叫做退出状态。 这个值是一个 0 到 255 之间的整数，说明命令执行成功或是失败。按照惯例，一个零值说明成功，其它所有值说明失败。 Shell 提供了一个参数，我们可以用它检查退出状态。用具体实例看一下：

```shell
[me@linuxbox ~]$ ls -d /usr/bin
/usr/bin
[me@linuxbox ~]$ echo $?
0
[me@linuxbox ~]$ ls -d /bin/usr
ls: cannot access /bin/usr: No such file or directory
[me@linuxbox ~]$ echo $?
2
```

**If 语句真正做的事情是计算命令执行成功或失败**：

```shell
[me@linuxbox ~]$ if true; then echo "It's true."; fi
It's true.
[me@linuxbox ~]$ if false; then echo "It's true."; fi
[me@linuxbox ~]$
```

##### 测试

到目前为止，经常与 if 一块使用的命令是 test。这个 test 命令执行各种各样的检查与比较。 它有两种等价模式：

```shell
test expression
```

比较流行的格式是：

```shell
[ expression ]
```

这里的 expression 是一个表达式，其执行结果是 true 或者是 false。当表达式为真时，这个 test 命令返回一个零 退出状态，当表达式为假时，test 命令退出状态为1。

##### 文件表达式

测试文件表达式

| 表达式          | 如果为真                                                     |
| :-------------- | :----------------------------------------------------------- |
| file1 -ef file2 | file1 和 file2 拥有相同的索引号（通过硬链接两个文件名指向相同的文件）。 |
| file1 -nt file2 | file1新于 file2。                                            |
| file1 -ot file2 | file1早于 file2。                                            |
| -b file         | file 存在并且是一个块（设备）文件。                          |
| -c file         | file 存在并且是一个字符（设备）文件。                        |
| -d file         | file 存在并且是一个目录。                                    |
| -e file         | file 存在。                                                  |
| -f file         | file 存在并且是一个普通文件。                                |
| -g file         | file 存在并且设置了组 ID。                                   |
| -G file         | file 存在并且由有效组 ID 拥有。                              |
| -k file         | file 存在并且设置了它的“sticky bit”。                        |
| -L file         | file 存在并且是一个符号链接。                                |
| -O file         | file 存在并且由有效用户 ID 拥有。                            |
| -p file         | file 存在并且是一个命名管道。                                |
| -r file         | file 存在并且可读（有效用户有可读权限）。                    |
| -s file         | file 存在且其长度大于零。                                    |
| -S file         | file 存在且是一个网络 socket。                               |
| -t fd           | fd 是一个定向到终端／从终端定向的文件描述符 。 这可以被用来决定是否重定向了标准输入／输出错误。 |
| -u file         | file 存在并且设置了 setuid 位。                              |
| -w file         | file 存在并且可写（有效用户拥有可写权限）。                  |
| -x file         | file 存在并且可执行（有效用户有执行／搜索权限）。            |

 在表达式中参数`$FILE`是怎样被引用的。引号并不是必需的，但这是为了**防范空参数**。如果`$FILE`的参数展开 是一个空值，就会导致一个错误（操作符将会被解释为非空的字符串而不是操作符）。用引号把参数引起来就 确保了操作符之后总是跟随着一个字符串，即使字符串为空。第二个，注意脚本末尾的 exit 命令。 这个 **exit** 命令接受一个单独的，可选的参数，其成为脚本的退出状态。当不传递参数时，退出状态默认为零。 以这种方式使用 exit 命令，则允许此脚本提示失败如果 `$FILE` 展开成一个不存在的文件名。这个 exit 命令 出现在脚本中的最后一行，是一个当一个脚本“运行到最后”（到达文件末尾），不管怎样， 默认情况下它以退出状态零终止。

类似地，通过带有一个整数参数的 **return** 命令，shell 函数可以返回一个退出状态。如果我们打算把 上面的脚本转变为一个 shell 函数，为了在更大的程序中包含此函数，我们用 return 语句来代替 exit 命令。

##### 字符串表达式

测试字符串表达式

| 表达式                               | 如果为真...                                                  |
| :----------------------------------- | :----------------------------------------------------------- |
| string                               | string 不为 null。                                           |
| -n string                            | 字符串 string 的长度大于零。                                 |
| -z string                            | 字符串 string 的长度为零。                                   |
| string1 = string2 string1 == string2 | string1 和 string2 相同. 单或双等号都可以，不过双等号更受欢迎。 |
| string1 != string2                   | string1 和 string2 不相同。                                  |
| string1 > string2                    | sting1 排列在 string2 之后。                                 |
| string1 < string2                    | string1 排列在 string2 之前。                                |

> 这个 > 和 <表达式操作符必须用引号引起来（或者是用反斜杠转义）， 当与 test 一块使用的时候。如果不这样，它们会被 shell 解释为重定向操作符，造成潜在地破坏结果。

##### 整型表达式

测试整数表达式

| 表达式                | 如果为真...                   |
| :-------------------- | :---------------------------- |
| integer1 -eq integer2 | integer1 等于 integer2.       |
| integer1 -ne integer2 | integer1 不等于 integer2.     |
| integer1 -le integer2 | integer1 小于或等于 integer2. |
| integer1 -lt integer2 | integer1 小于 integer2.       |
| integer1 -ge integer2 | integer1 大于或等于 integer2. |
| integer1 -gt integer2 | integer1 大于 integer2.       |

##### 更现代的测试版本

目前的 bash 版本包括一个复合命令，作为加强的 test 命令替代物。它使用以下语法：

```
[[ expression ]]
```

这里，类似于 test，expression 是一个表达式，其计算结果为真或假。这个`[[ ]]`命令非常相似于 test 命令（它支持所有的表达式），但是增加了一个重要的新的字符串表达式：

```
string1 =~ regex
```

其返回值为真，如果 string1匹配扩展的正则表达式 regex。这就为执行比如数据验证等任务提供了许多可能性。 在我们前面的整数表达式示例中，如果常量 INT 包含除了整数之外的任何数据，脚本就会运行失败。这个脚本 需要一种方法来证明此常量包含一个整数。使用 `[[ ]]` 和 `=~` 字符串表达式操作符，我们能够这样来改进脚本：

```bash
#!/bin/bash
# test-integer2: evaluate the value of an integer.
INT=-5
if [[ "$INT" =~ ^-?[0-9]+$ ]]; then
    if [ $INT -eq 0 ]; then
        echo "INT is zero."
    else
        if [ $INT -lt 0 ]; then
            echo "INT is negative."
        else
            echo "INT is positive."
        fi
        if [ $((INT % 2)) -eq 0 ]; then
            echo "INT is even."
        else
            echo "INT is odd."
        fi
    fi
else
    echo "INT is not an integer." >&2
    exit 1
fi
```

通过应用正则表达式，我们能够限制 INT 的值只是字符串，其开始于一个可选的减号，随后是一个或多个数字。 这个表达式也消除了空值的可能性。

`[[ ]]`添加的另一个功能是`==`操作符支持类型匹配，正如路径名展开所做的那样。例如：

```shell
[me@linuxbox ~]$ FILE=foo.bar
[me@linuxbox ~]$ if [[ $FILE == foo.* ]]; then
> echo "$FILE matches pattern 'foo.*'"
> fi
foo.bar matches pattern 'foo.*'
```

这就使`[[ ]]`有助于计算文件和路径名。

##### (( )) - 为整数设计

除了 `[[ ]]` 复合命令之外，bash 也提供了 `(( ))` 复合命名，其有利于操作整数。它支持一套 完整的算术计算，我们将在第35章中讨论这个主题。

`(( ))`被用来执行算术真测试。如果算术计算的结果是非零值，则一个算术真测试值为真。

```shell
[me@linuxbox ~]$ if ((1)); then echo "It is true."; fi
It is true.
[me@linuxbox ~]$ if ((0)); then echo "It is true."; fi
[me@linuxbox ~]$
```

使用`(( ))`，我们能够略微简化 test-integer2脚本，像这样：

```bash
#!/bin/bash
# test-integer2a: evaluate the value of an integer.
INT=-5
if [[ "$INT" =~ ^-?[0-9]+$ ]]; then
    if ((INT == 0)); then
        echo "INT is zero."
    else
        if ((INT < 0)); then
            echo "INT is negative."
        else
            echo "INT is positive."
        fi
        if (( ((INT % 2)) == 0)); then
            echo "INT is even."
        else
            echo "INT is odd."
        fi
    fi
else
    echo "INT is not an integer." >&2
    exit 1
fi
```

注意我们**使用小于和大于符号，以及==用来测试是否相等**。这是使用整数较为自然的语法了。也要 注意，因为**复合命令 `(( ))` 是 shell 语法的一部分，而不是一个普通的命令，而且它只处理整数， 所以它能够通过名字识别出变量，而不需要执行展开操作**。我们将在第35中进一步讨论 `(( ))` 命令 和相关的算术展开操作。

##### 结合表达式

逻辑操作符

| 操作符 | 测试 | [[ ]] and (( )) |
| :----- | :--- | :-------------- |
| AND    | -a   | &&              |
| OR     | -o   | \|\|            |
| NOT    | !    | !               |

我们也可以对表达式**使用圆括号，为的是分组**。如果不使用括号，那么否定只应用于第一个 表达式，而不是两个组合的表达式。用 test 可以这样来编码：

```bash
if [ ! \( $INT -ge $MIN_VAL -a $INT -le $MAX_VAL \) ]; then
    echo "$INT is outside $MIN_VAL to $MAX_VAL."
else
    echo "$INT is in range."
fi
```

因为 **test 使用的所有的表达式和操作符都被 shell 看作是命令参数**（不像 `[[ ]]` 和 `(( ))` ）， 对于 bash 有特殊含义的字符，比如说 ，(，和 )，必须引起来或者是转义。

知道了 test 和 `[[ ]]` 基本上完成相同的事情，哪一个更好呢？test 更传统（是 POSIX 的一部分）， 然而 `[[ ]]` 特定于 bash。知道怎样使用 test 很重要，因为它被非常广泛地应用，但是显然 `[[ ]]` 更 有助于，并更易于编码。

##### 控制操作符：分支的另一种方法

bash 支持两种可以执行分支任务的控制操作符。这个 `&&（AND）`和`||（OR）`操作符作用如同 复合命令`[[ ]]`中的逻辑操作符。这是语法：

```shell
command1 && command2
```

和

```shell
command1 || command2
```

理解这些操作很重要。对于 && 操作符，先执行 command1，如果并且只有如果 command1 执行成功后， 才会执行 command2。对于 || 操作符，先执行 command1，如果并且只有如果 command1 执行失败后， 才会执行 command2。

在实际中，它意味着我们可以做这样的事情：

```shell
[me@linuxbox ~]$ mkdir temp && cd temp
```

这会创建一个名为 temp 的目录，并且若它执行成功后，当前目录会更改为 temp。第二个命令会尝试 执行只有当 mkdir 命令执行成功之后。同样地，一个像这样的命令：

```shell
[me@linuxbox ~]$ [ -d temp ] || mkdir temp
```

会测试目录 temp 是否存在，并且只有测试失败之后，才会创建这个目录。这种构造类型非常有助于在 脚本中处理错误，这个主题我们将会在随后的章节中讨论更多。例如，我们在脚本中可以这样做：

```shell
[ -d temp ] || exit 1
```

如果这个脚本要求目录 temp，且目录不存在，然后脚本会终止，并返回退出状态1。

### 26. 读取键盘输入

##### read - 从标准输入读取数值

```shell
read [-options] [variable...]
```

variable 是用来存储输入数值的一个或多个变量名。 如果没有提供变量名，shell 变量 **REPLY** 会包含数据行。

例子：

```bash
[me@linuxbox ~]$ read-multiple
Enter one or more values > a b c d e
var1 = 'a'
var2 = 'b'
var3 = 'c'
var4 = 'd'
var5 = 'e'
[me@linuxbox ~]$ read-multiple
Enter one or more values > a
var1 = 'a'
var2 = ''
var3 = ''
var4 = ''
var5 = ''
[me@linuxbox ~]$ read-multiple
Enter one or more values > a b c d e f g
var1 = 'a'
var2 = 'b'
var3 = 'c'
var4 = 'd'
var5 = 'e f g'
```

read 选项

| 选项         | 说明                                                         |
| :----------- | :----------------------------------------------------------- |
| -a array     | 把输入赋值到数组 array 中，从索引号零开始。我们 将在第36章中讨论数组问题。 |
| -d delimiter | 用字符串 delimiter 中的第一个字符指示输入结束，而不是一个换行符。 |
| -e           | 使用 Readline 来处理输入。这使得与命令行相同的方式编辑输入。 |
| -n num       | 读取 num 个输入字符，而不是整行。                            |
| -p prompt    | 为输入显示提示信息，使用字符串 prompt。                      |
| -r           | Raw mode. 不把反斜杠字符解释为转义字符。                     |
| -s           | Silent mode. 不会在屏幕上显示输入的字符。当输入密码和其它确认信息的时候，这会很有帮助。 |
| -t seconds   | 超时. 几秒钟后终止输入。read 会返回一个非零退出状态，若输入超时。 |
| -u fd        | 使用文件描述符 fd 中的输入，而不是标准输入。                 |

通过 -t 和 -s 选项，我们可以编写一个这样的脚本，读取“秘密”输入，并且如果在特定的时间内 输入没有完成，就终止输入。

```bash
#!/bin/bash
# read-secret: input a secret pass phrase
if read -t 10 -sp "Enter secret pass phrase > " secret_pass; then
    echo -e "\nSecret pass phrase = '$secret_pass'"
else
    echo -e "\nInput timed out" >&2
    exit 1
if
```

这个脚本提示用户输入一个密码，并等待输入10秒钟。如果在特定的时间内没有完成输入， 则脚本会退出并返回一个错误。因为包含了一个 -s 选项，所以输入的密码不会出现在屏幕上。

##### IFS

通常，shell 对提供给 read 的输入按照单词进行分离。正如我们所见到的，这意味着多个由一个或几个空格 分离开的单词在输入行中变成独立的个体，并被 read 赋值给单独的变量。这种行为由 shell 变量__IFS__ （内部字符分隔符）配置。IFS 的默认值包含一个空格，一个 tab，和一个换行符，每一个都会把 字段分割开。

我们可以调整 IFS 的值来控制输入字段的分离。例如，这个 /etc/passwd 文件包含的数据行 使用冒号作为字段分隔符。通过把 IFS 的值更改为单个冒号，我们可以使用 read 读取 /etc/passwd 中的内容，并成功地把字段分给不同的变量。这个就是做这样的事情：

```bash
#!/bin/bash
# read-ifs: read fields from a file
FILE=/etc/passwd
read -p "Enter a user name > " user_name
file_info=$(grep "^$user_name:" $FILE)
if [ -n "$file_info" ]; then
    IFS=":" read user pw uid gid name home shell <<< "$file_info"
    echo "User = '$user'"
    echo "UID = '$uid'"
    echo "GID = '$gid'"
    echo "Full Name = '$name'"
    echo "Home Dir. = '$home'"
    echo "Shell = '$shell'"
else
    echo "No such user '$user_name'" >&2
    exit 1
fi
```

这个脚本提示用户输入系统中一个帐户的用户名，然后显示在文件 /etc/passwd/ 文件中关于用户记录的 不同字段。这个脚本包含两个有趣的文本行。 第一个是：

```bash
file_info=$(grep "^$user_name:" $FILE)
```

这一行把 grep 命令的输入结果赋值给变量 file_info。grep 命令使用的正则表达式 确保用户名只会在 /etc/passwd 文件中匹配一个文本行。

第二个有意思的文本行是：

```bash
IFS=":" read user pw uid gid name home shell <<< "$file_info"
```

这一行由三部分组成：一个变量赋值，一个带有一串参数的 read 命令，和一个奇怪的新的重定向操作符。 我们首先看一下变量赋值。

Shell 允许在一个命令之前立即发生一个或多个变量赋值。这些赋值为跟随着的命令更改环境变量。 这个赋值的影响是暂时的；只是在命令存在期间改变环境变量。在这种情况下，IFS 的值改为一个冒号。 另外，我们也可以这样编码：

```bash
OLD_IFS="$IFS"
IFS=":"
read user pw uid gid name home shell <<< "$file_info"
IFS="$OLD_IFS"
```

我们先存储 IFS 的值，然后赋给一个新值，再执行 read 命令，最后把 IFS 恢复原值。显然，完成相同的任务， 在命令之前放置变量名赋值是一种更简明的方式。

这个 `<<<` 操作符指示一个 here 字符串。一个 here 字符串就像一个 here 文档，只是比较简短，由 单个字符串组成。在这个例子中，来自 /etc/passwd 文件的数据发送给 read 命令的标准输入。 我们可能想知道为什么选择这种相当晦涩的方法而不是：

```bash
echo "$file_info" | IFS=":" read user pw uid gid name home shell
```

> 你不能管道 read
>
> 虽然通常 read 命令接受标准输入，但是你不能这样做：
>
> echo “foo” | read
>
> 我们期望这个命令能生效，但是它不能。这个命令将显示成功，但是 REPLY 变量 总是为空。为什么会这样？
>
> 答案与 shell 处理管道线的方式有关系。在 bash（和其它 shells，例如 sh）中，管道线 会创建子 shell。它们是 shell 的副本，且用来执行命令的环境变量在管道线中。 上面示例中，read 命令将在子 shell 中执行。
>
> 在类 Unix 的系统中，子 shell 执行的时候，会为进程创建父环境的副本。当进程结束 之后，环境副本就会被破坏掉。这意味着一个子 shell 永远不能改变父进程的环境。read 赋值变量， 然后会变为环境的一部分。在上面的例子中，read 在它的子 shell 环境中，把 foo 赋值给变量 REPLY， 但是当命令退出后，子 shell 和它的环境将被破坏掉，这样赋值的影响就会消失。

##### 校正输入

校正各种输入的示例程序：

```bash
#!/bin/bash
# read-validate: validate input
invalid_input () {
    echo "Invalid input '$REPLY'" >&2
    exit 1
}
read -p "Enter a single item > "
# input is empty (invalid)
[[ -z $REPLY ]] && invalid_input
# input is multiple items (invalid)
(( $(echo $REPLY | wc -w) > 1 )) && invalid_input
# is input a valid filename?
if [[ $REPLY =~ ^[-[:alnum:]\._]+$ ]]; then
    echo "'$REPLY' is a valid filename."
    if [[ -e $REPLY ]]; then
        echo "And file '$REPLY' exists."
    else
        echo "However, file '$REPLY' does not exist."
    fi
    # is input a floating point number?
    if [[ $REPLY =~ ^-?[[:digit:]]*\.[[:digit:]]+$ ]]; then
        echo "'$REPLY' is a floating point number."
    else
        echo "'$REPLY' is not a floating point number."
    fi
    # is input an integer?
    if [[ $REPLY =~ ^-?[[:digit:]]+$ ]]; then
        echo "'$REPLY' is an integer."
    else
        echo "'$REPLY' is not an integer."
    fi
else
    echo "The string '$REPLY' is not a valid filename."
fi
```

##### 菜单

例子：构建一个菜单驱动程序

```bash
#!/bin/bash
# read-menu: a menu driven system information program
clear
echo "
Please Select:

    1\. Display System Information
    2\. Display Disk Space
    3\. Display Home Space Utilization
    0\. Quit
"
read -p "Enter selection [0-3] > "

if [[ $REPLY =~ ^[0-3]$ ]]; then
    if [[ $REPLY == 0 ]]; then
        echo "Program terminated."
        exit
    fi
    if [[ $REPLY == 1 ]]; then
        echo "Hostname: $HOSTNAME"
        uptime
        exit
    fi
    if [[ $REPLY == 2 ]]; then
        df -h
        exit
    fi
    if [[ $REPLY == 3 ]]; then
        if [[ $(id -u) -eq 0 ]]; then
            echo "Home Space Utilization (All Users)"
            du -sh /home/*
        else
            echo "Home Space Utilization ($USER)"
            du -sh $HOME
        fi
        exit
    fi
else
    echo "Invalid entry." >&2
    exit 1
fi
```

### 27. 流程控制 while/until 循环

##### while

while 命令的语法是：

```shell
while commands; do commands; done
```

例子：

```bash
#!/bin/bash
# while-count: display a series of numbers
count=1
while [ $count -le 5 ]; do
    echo $count
    count=$((count + 1))
done
echo "Finished."
```

###### 跳出循环

bash 提供了两个内部命令，它们可以用来在循环内部控制程序流程。这个 **break** 命令立即终止一个循环， 且程序继续执行循环之后的语句。这个 **continue** 命令导致程序跳过循环中剩余的语句，且程序继续执行 下一次循环。

##### until

与while的判断条件正好相反

在脚本中使用 until 命令：

```bash
#!/bin/bash
# until-count: display a series of numbers
count=1
until [ $count -gt 5 ]; do
    echo $count
    count=$((count + 1))
done
echo "Finished."
```

##### 使用循环读取文件

```bash
#!/bin/bash
# while-read: read lines from a file
while read distro version release; do
    printf "Distro: %s\tVersion: %s\tReleased: %s\n" \
        $distro \
        $version \
        $release
done < distros.txt
```

把重定向操作符放置到 done 语句之后。循环将使用 read 从重定向文件中读取字段。

也有可能把标准输入管道到循环中。

```bash
#!/bin/bash
# while-read2: read lines from a file
sort -k 1,1 -k 2n distros.txt | while read distro version release; do
    printf "Distro: %s\tVersion: %s\tReleased: %s\n" \
        $distro \
        $version \
        $release
done
```

### 28. 流程控制 case分支

Bash 的多选复合命令称为 case。它的语法规则如下所示：

```bash
case word in
    [pattern [| pattern]...) commands ;;]...
esac
```

##### 模式

case 模式实例

| 模式         | 描述                                                         |
| :----------- | :----------------------------------------------------------- |
| a)           | 若单词为 “a”，则匹配                                         |
| [[:alpha:]]) | 若单词是一个字母字符，则匹配                                 |
| ???)         | 若单词只有3个字符，则匹配                                    |
| *.txt)       | 若单词以 “.txt” 字符结尾，则匹配                             |
| *)           | 匹配任意单词。把这个模式做为 case 命令的最后一个模式，是一个很好的做法， 可以捕捉到任意一个与先前模式不匹配的数值；也就是说，捕捉到任何可能的无效值。 |

模式使用实例：

```bash
#!/bin/bash
read -p "enter word > "
case $REPLY in
    [[:alpha:]])        echo "is a single alphabetic character." ;;
    [ABC][0-9])         echo "is A, B, or C followed by a digit." ;;
    ???)                echo "is three characters long." ;;
    *.txt)              echo "is a word ending in '.txt'" ;;
    *)                  echo "is something else." ;;
esac
```

可以使用竖线字符作为分隔符，把多个模式结合起来。这就创建了一个 **“或”** 条件模式。这对于处理诸如大小写字符很有用处。例如：

```bash
#!/bin/bash
# case-menu: a menu driven system information program
clear
echo "
Please Select:
A. Display System Information
B. Display Disk Space
C. Display Home Space Utilization
Q. Quit
"
read -p "Enter selection [A, B, C or Q] > "
case $REPLY in
q|Q) echo "Program terminated."
     exit
     ;;
a|A) echo "Hostname: $HOSTNAME"
     uptime
     ;;
b|B) df -h
     ;;
c|C) if [[ $(id -u) -eq 0 ]]; then
         echo "Home Space Utilization (All Users)"
         du -sh /home/*
     else
         echo "Home Space Utilization ($USER)"
         du -sh $HOME
     fi
     ;;
*)   echo "Invalid entry" >&2
     exit 1
     ;;
esac
```

##### 执行多个动作

添加 “;;&” 表达式来匹配 多个测试条件：

```bash
#!/bin/bash
# case4-2: test a character
read -n 1 -p "Type a character > "
echo
case $REPLY in
    [[:upper:]])    echo "'$REPLY' is upper case." ;;&
    [[:lower:]])    echo "'$REPLY' is lower case." ;;&
    [[:alpha:]])    echo "'$REPLY' is alphabetic." ;;&
    [[:digit:]])    echo "'$REPLY' is a digit." ;;&
    [[:graph:]])    echo "'$REPLY' is a visible character." ;;&
    [[:punct:]])    echo "'$REPLY' is a punctuation symbol." ;;&
    [[:space:]])    echo "'$REPLY' is a whitespace character." ;;&
    [[:xdigit:]])   echo "'$REPLY' is a hexadecimal digit." ;;&
esac
```

当我们运行这个脚本的时候，我们得到这些：

```bash
[me@linuxbox ~]$ case4-2
Type a character > a
'a' is lower case.
'a' is alphabetic.
'a' is a visible character.
'a' is a hexadecimal digit.
```

添加的 “;;&” 的语法允许 case 语句继续执行下一条测试，而不是简单地终止运行。

### 29. 位置参数

##### 访问命令行

```shell
[me@linuxbox ~]$ posit-param a b c d
$0 = /home/me/bin/posit-param
$1 = a
$2 = b
$3 = c
$4 = d
$5 =
$6 =
$7 =
$8 =
$9 =
```

注意： 实际上通过参数展开方式你可以访问的参数个数多于9个。只要指定一个大于9的数字，用花括号把该数字括起来就可以。 例如 ${10}， ${55}， ${211}，等等。

##### 确定参数个数

shell 还提供了一个名为 $#，可以得到命令行参数个数的变量。

##### shift - 访问多个参数的利器

执行一次 shift 命令， 就会导致所有的位置参数 “向下移动一个位置”。事实上，用 shift 命令也可以 处理只有一个参数的情况（除了其值永远不会改变的变量 $0）：

```bash
#!/bin/bash
# posit-param2: script to display all arguments
count=1
while [[ $# -gt 0 ]]; do
    echo "Argument $count = $1"
    count=$((count + 1))
    shift
done
```

每次 shift 命令执行的时候，变量 $2 的值会移动到变量 $1 中，变量 $3 的值会移动到变量 $2 中，依次类推。 变量 $# 的值也会相应的减1。

##### 简单应用

一个简单的输出文件信息的程序：

```bash
#!/bin/bash
# file_info: simple file information program
PROGNAME=$(basename $0)
if [[ -e $1 ]]; then
    echo -e "\nFile Type:"
    file $1
    echo -e "\nFile Status:"
    stat $1
else
    echo "$PROGNAME: usage: $PROGNAME file" >&2
    exit 1
fi
```

basename 命令清除 一个路径名的开头部分，只留下一个文件的基本名称。在我们的程序中，basename 命令清除了包含在 $0 位置参数 中的路径名的开头部分，$0 中包含着我们示例程序的完整路径名。

##### Shell 函数中使用位置参数

一个 shell 函数：

```bash
file_info () {
  # file_info: function to display file information
  if [[ -e $1 ]]; then
      echo -e "\nFile Type:"
      file $1
      echo -e "\nFile Status:"
      stat $1
  else
      echo "$FUNCNAME: usage: $FUNCNAME file" >&2
      return 1
  fi
}
```

现在，如果一个包含 shell 函数 file_info 的**脚本**调用该函数，且带有一个文件名参数，那这个参数会传递给 file_info 函数。

注意那个 PROGNAME 变量已经改成 shell 变量 FUNCNAME 了。shell 会自动更新 FUNCNAME 变量，以便跟踪当前执行的 shell 函数。**注意位置参数 $0 总是包含命令行中第一项的完整路径名**（例如，该程序的名字）， 但不会包含这个我们可能期望的 shell 函数的名字。

##### 处理集体位置参数

 shell 提供了两种特殊的参数。他们二者都能扩展成完整的位置参数列表，但以相当微妙的方式略有不同。它们是：

\* 和 @ 特殊参数

| 参数 | 描述                                                         |
| ---- | ------------------------------------------------------------ |
| $*   | 展开成一个从1开始的位置参数列表。当它被用双引号引起来的时候，展开成一个由双引号引起来的字符串，包含了所有的位置参数，每个位置参数由 shell 变量 IFS 的第一个字符（默认为一个**空格**）分隔开。 |
| $@   | 展开成一个从1开始的位置参数列表。当它被用双引号引起来的时候， 它把每一个位置参数展开成一个由**双引号**引起来的分开的字符串。 |

面这个脚本用程序中展示了这些特殊参数：

```bash
#!/bin/bash
# posit-params3 : script to demonstrate $* and $@
print_params () {
    echo "\$1 = $1"
    echo "\$2 = $2"
    echo "\$3 = $3"
    echo "\$4 = $4"
}
pass_params () {
    echo -e "\n" '$* :';      print_params   $*
    echo -e "\n" '"$*" :';    print_params   "$*"
    echo -e "\n" '$@ :';      print_params   $@
    echo -e "\n" '"$@" :';    print_params   "$@"
}
pass_params "word" "words with spaces"
```

在这个相当复杂的程序中，我们创建了两个参数： “word” 和 “words with spaces”，然后把它们 传递给 pass_params 函数。这个函数，依次，再把两个参数传递给 print_params 函数， 使用了特殊参数 $* 和 $@ 提供的四种可用方法。脚本运行后，揭示了这两个特殊参数存在的差异：

```bash
[me@linuxbox ~]$ posit-param3
 $* :
$1 = word
$2 = words
$3 = with
$4 = spaces
 "$*" :
$1 = word words with spaces
$2 =
$3 =
$4 =
 $@ :
$1 = word
$2 = words
$3 = with
$4 = spaces
 "$@" :
$1 = word
$2 = words with spaces
$3 =
$4 =
```

通过我们的参数，$* 和 $@ 两个都产生了一个有四个词的结果：

```
word words with spaces
"$*" produces a one word result:
    "word words with spaces"
"$@" produces a two word result:
    "word" "words with spaces"
```

这个结果符合我们实际的期望。我们从中得到的教训是尽管 shell 提供了四种不同的得到位置参数列表的方法， 但到目前为止， **“$@” 在大多数情况下是最有用的方法，因为它保留了每一个位置参数的完整性**。

##### 一个更复杂的应用

给程序添加如下几个命令行选项：

- **输出文件**。 我们将添加一个选项，以便指定一个文件名，来包含程序的输出结果。 选项格式要么是 -f file，要么是 --file file
- **交互模式**。这个选项将提示用户输入一个输出文件名，然后判断是否指定的文件已经存在了。如果文件存在， 在覆盖这个存在的文件之前会提示用户。这个选项可以通过 -i 或者 --interactive 来指定。
- **帮助**。指定 -h 选项 或者是 --help 选项，可导致程序输出提示性的使用信息。

处理命令行选项所需的代码：

```bash
usage () {
    echo "$PROGNAME: usage: $PROGNAME [-f file | -i]"
    return
}
# process command line options
interactive=
filename=
while [[ -n $1 ]]; do
    case $1 in
    -f | --file)            shift
                            filename=$1
                            ;;
    -i | --interactive)     interactive=1
                            ;;
    -h | --help)            usage
                            exit
                            ;;
    *)                      usage >&2
                            exit 1
                            ;;
    esac
    shift
done
```

首先，我们添加了一个叫做 usage 的 shell 函数，以便显示帮助信息，当启用帮助选项或敲写了一个未知选项的时候。

下一步，我们开始处理循环。当位置参数 $1 不为空的时候，这个循环会持续运行。在循环的底部，有一个 shift 命令， 用来提升位置参数，以便确保该循环最终会终止。在循环体内，我们使用了一个 case 语句来检查当前位置参数的值， 看看它是否匹配某个支持的选项。若找到了匹配项，就会执行与之对应的代码。若没有，就会打印出程序使用信息， 该脚本终止且执行错误。

处理 -f 参数的方式很有意思。当监测到 -f 参数的时候，会执行一次 shift 命令，从而提升位置参数 $1 为 伴随着 -f 选项的 filename 参数。

我们下一步添加代码来实现交互模式：

```bash
# interactive mode
if [[ -n $interactive ]]; then
    while true; do
        read -p "Enter name of output file: " filename
        if [[ -e $filename ]]; then
            read -p "'$filename' exists. Overwrite? [y/n/q] > "
            case $REPLY in
            Y|y)    break
                    ;;
            Q|q)    echo "Program terminated."
                    exit
                    ;;
            *)      continue
                    ;;
            esac
        elif [[ -z $filename ]]; then
            continue
        else
            break
        fi
    done
fi
```

若 interactive 变量不为空，就会启动一个无休止的循环，该循环包含文件名提示和随后存在的文件处理代码。 如果所需要的输出文件已经存在，则提示用户覆盖，选择另一个文件名，或者退出程序。如果用户选择覆盖一个 已经存在的文件，则会执行 break 命令终止循环。注意 case 语句是怎样只检测用户选择了覆盖还是退出选项。 其它任何选择都会导致循环继续并提示用户再次选择。

##### [ expression ] 和 [[ expression ]] 的区别：

```bash
#! /bin/bash

read

echo '[ -n $REPLY ] : ' 
    [ -n $REPLY ] && echo "true" || echo "false"
echo '[ -n "$REPLY" ] : ' 
    [ -n "$REPLY" ] && echo "true" || echo "false"
echo '[[ -n $REPLY ]] : ' 
    [[ -n $REPLY ]] && echo "true" || echo "false"
echo '[[ -n "$REPLY" ]] : ' 
    [[ -n "$REPLY" ]] && echo "true" || echo "false"

```

假设执行read，不输入，直接enter，那么按道理`-n $REPLY`应该为false

结果：

```shell
[panyliu@VM_0_6_centos bin]$ sh foo.sh 

[ -n $REPLY ] : 
true
[ -n "$REPLY" ] : 
false
[[ -n $REPLY ]] : 
false
[[ -n "$REPLY" ]] : 
false
```

总结：

| expression  | [ ]   | [[ ]] |
| ----------- | ----- | ----- |
| -n $REPLY   | true  | false |
| -n "$REPLY" | false | false |

但是`[ -n $REPLY ]`的结果为true, 也就是说如果采用这种测试形式，那么在没有输入的时候也不会得到长度为0的字符串。

尽量采用`[[  ]]`的形式即可。

### 30. 流程控制 for循环

##### for: 传统 shell 格式

来的 for 命令语法是：

```bash
for variable [in words]; do
    commands
done
```

words 是一个可选的条目列表， 其值会按顺序赋值给 variable，commands 是在每次循环迭代中要执行的命令。

在命令行中 for 命令是很有用的。我们可以很容易的说明它是如何工作的：

```bash
[me@linuxbox ~]$ for i in A B C D; do echo $i; done
A
B
C
D
```

for 命令真正强大的功能是我们可以通过许多有趣的方式创建 words 列表。例如，通过**花括号展开**：

```bash
[me@linuxbox ~]$ for i in {A..D}; do echo $i; done
A
B
C
D
```

或者**路径名展开**：

```bash
[me@linuxbox ~]$ for i in distros*.txt; do echo $i; done
distros-by-date.txt
distros-dates.txt
distros-key-names.txt
distros-key-vernums.txt
distros-names.txt
distros.txt
distros-vernums.txt
distros-versions.txt
```

或者**命令替换**：

```bash
#!/bin/bash
# longest-word : find longest string in a file
while [[ -n $1 ]]; do
    if [[ -r $1 ]]; then
        max_word=
        max_len=0
        for i in $(strings $1); do
            len=$(echo $i | wc -c)
            if (( len > max_len )); then
                max_len=$len
                max_word=$i
            fi
        done
        echo "$1: '$max_word' ($max_len characters)"
    fi
    shift
done
```

在这个示例中，我们要在一个文件中查找最长的字符串。当在命令行中给出一个或多个文件名的时候， 该程序会使用 strings 程序（其包含在 GNU binutils 包中），为每一个文件产生一个可读的文本格式的 “words” 列表。 然后这个 for 循环依次处理每个单词，判断当前这个单词是否为目前为止找到的最长的一个。当循环结束的时候，显示出最长的单词。

**如果省略掉 for 命令的可选项 words 部分，for 命令会默认处理位置参数。** 我们将修改 longest-word 脚本，来使用这种方式：

```bash
#!/bin/bash
# longest-word2 : find longest string in a file
for i; do
    if [[ -r $i ]]; then
        max_word=
        max_len=0
        for j in $(strings $i); do
            len=$(echo $j | wc -c)
            if (( len > max_len )); then
                max_len=$len
                max_word=$j
            fi
        done
        echo "$i: '$max_word' ($max_len characters)"
    fi
done
```

正如我们所看到的，我们已经更改了最外围的循环，用 for 循环来代替 while 循环。通过省略 for 命令的 words 列表， 用位置参数替而代之。在循环体内，之前的变量 i 已经改为变量 j。**同时 shift 命令也被淘汰掉了**。

##### for: C 语言格式

新版本的 bash 已经添加了第二种格式的 for 命令语法，该语法相似于 C 语言中的 for 语法格式。 其它许多编程语言也支持这种格式：

```bash
for (( expression1; expression2; expression3 )); do
    commands
done
```

一个典型应用：

```bash
#!/bin/bash
# simple_counter : demo of C style for command
for (( i=0; i<5; i=i+1 )); do
    echo $i
done
```

这里i++也可以。

### 31.字符串和数字

#### 参数展开

##### 基本参数

| 形式     | 说明（例子）                                               |
| -------- | ---------------------------------------------------------- |
| **$a**   | $后面所有的字符串都会被看作变量名                          |
| **${a}** | 有所限制，只有{}里面才被看做变量，值可以和{}外的字符串拼接 |

##### 管理空变量的展开

| 形式                   | 说明（例子）                                                 |
| ---------------------- | ------------------------------------------------------------ |
| **${parameter:-word}** | 若 parameter 没有设置（例如，不存在）或者为空，展开结果是 word 的值。若 parameter 不为空，则展开结果是 parameter 的值。 |
| **${parameter:=word}** | 若 parameter 没有设置或为空，展开结果是 word 的值。另外，word 的值会赋值给 parameter。 若 parameter 不为空，展开结果是 parameter 的值。 |
| **${parameter:?word}** | 若 parameter 没有设置或为空，这种展开导致脚本带有错误退出，并且 word 的内容会发送到标准错误。若 parameter 不为空， 展开结果是 parameter 的值。 |
| **${parameter:+word}** | 若 parameter 没有设置或为空，展开结果为空。若 parameter 不为空， 展开结果是 word 的值会替换掉 parameter 的值；然而，parameter 的值不会改变。 |

##### 返回变量名的参数展开

shell 具有返回变量名的能力。这会用在一些相当独特的情况下。

```shell
${!prefix*}

${!prefix@}
```

这种展开会返回以 prefix 开头的已有变量名。

##### 字符串展开

| 形式                                                         | 说明（例子）                                                 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| **${#parameter}**                                            | 展开成由 parameter 所包含的字符串的长度。                    |
| **${parameter:offset}**<br />**${parameter:offset:length}**  | 这些展开用来从 parameter 所包含的字符串中提取一部分字符。提取的字符始于 第 offset 个字符（从字符串开头算起）直到字符串的末尾，除非指定提取的长度。 |
| **${parameter#pattern}**<br />**${parameter##pattern}**      | 这些展开会从 paramter 所包含的字符串中清除开头一部分文本，这些字符要匹配定义的 patten。pattern 是 通配符模式，就如那些用在路径名展开中的模式。这两种形式的差异之处是该 # 形式清除最短的匹配结果， 而该 ## 模式清除最长的匹配结果。 |
| **${parameter%pattern}**<br />**${parameter%%pattern}**      | 这些展开和上面的 # 和 ## 展开一样，除了它们清除的文本从 parameter 所包含字符串的末尾开始，而不是开头。 |
| **${parameter/pattern/string}**<br />**${parameter//pattern/string}**<br />**${parameter/#pattern/string}**<br />**${parameter/%pattern/string}** | 这种形式的展开对 parameter 的内容执行查找和替换操作。如果找到了匹配通配符 pattern 的文本， 则用 string 的内容替换它。在正常形式下，只有第一个匹配项会被替换掉。在该 // 形式下，**所有**的匹配项都会被替换掉。 该 /# 要求匹配项出现在字符串的开头，而 /% 要求匹配项出现在字符串的末尾。/string 可能会省略掉，这样会 导致删除匹配的文本。 |

##### 大小写转换

declare 命令可以用来把字符串规范成大写或小写字符。使用 declare 命令，我们能强制一个 变量总是包含所需的格式，无论如何赋值给它。

```bash
#!/bin/bash
# ul-declare: demonstrate case conversion via declare
declare -u upper
declare -l lower
if [[ $1 ]]; then
    upper="$1"
    lower="$1"
    echo $upper
    echo $lower
fi
```

 大小写转换参数展开

| 格式           | 结果                                                        |
| :------------- | :---------------------------------------------------------- |
| ${parameter,,} | 把 parameter 的值全部展开成小写字母。                       |
| ${parameter,}  | 仅仅把 parameter 的第一个字符展开成小写字母。               |
| ${parameter^^} | 把 parameter 的值全部转换成大写字母。                       |
| ${parameter^}  | 仅仅把 parameter 的第一个字符转换成大写字母（首字母大写）。 |

#### 算术求值和展开

##### 数基

指定不同的数基

| 表示法      | 描述                                                         |
| :---------- | :----------------------------------------------------------- |
| number      | 默认情况下，没有任何表示法的数字被看做是十进制数（以10为底）。 |
| 0number     | 在算术表达式中，以零开头的数字被认为是八进制数。             |
| 0xnumber    | 十六进制表示法                                               |
| base#number | number 以 base 为底                                          |

##### 一元运算符

算术运算符

| 运算符 | 描述         |
| :----- | :----------- |
| +      | 加           |
| -      | 减           |
| *      | 乘           |
| /      | 整除         |
| **     | 乘方         |
| %      | 取模（余数） |

##### 赋值运算符

我们也能在算术表达式中执行赋值运算：

```bash
[me@linuxbox ~]$ foo=
[me@linuxbox ~]$ echo $foo
[me@linuxbox ~]$ if (( foo = 5 ));then echo "It is true."; fi
It is true.
[me@linuxbox ~]$ echo $foo
5
```

赋值运算符

| 表示法             | 描述                                                         |
| :----------------- | :----------------------------------------------------------- |
| parameter = value  | 简单赋值。给 parameter 赋值。                                |
| parameter += value | 加。等价于 parameter = parameter + value。                   |
| parameter -= value | 减。等价于 parameter = parameter – value。                   |
| parameter *= value | 乘。等价于 parameter = parameter * value。                   |
| parameter /= value | 整除。等价于 parameter = parameter / value。                 |
| parameter %= value | 取模。等价于 parameter = parameter % value。                 |
| parameter++        | 后缀自增变量。等价于 parameter = parameter + 1 (但，要看下面的讨论)。 |
| parameter--        | 后缀自减变量。等价于 parameter = parameter - 1。             |
| ++parameter        | 前缀自增变量。等价于 parameter = parameter + 1。             |
| --parameter        | 前缀自减变量。等价于 parameter = parameter - 1。             |

##### 位运算符

位运算符

| 运算符 | 描述                                         |
| :----- | :------------------------------------------- |
| ~      | 按位取反。对一个数字**所有**位取反。         |
| <<     | 位左移. 把一个数字的所有位向左移动。         |
| >>     | 位右移. 把一个数字的所有位向右移动。         |
| &      | 位与。对两个数字的所有位执行一个 AND 操作。  |
|        |                                              |
| ^      | 位异或。对两个数字的所有位执行一个异或操作。 |

##### 逻辑运算符

比较运算符

| 运算符            | 描述                                                         |
| :---------------- | :----------------------------------------------------------- |
| <=                | 小于或相等                                                   |
| >=                | 大于或相等                                                   |
| <                 | 小于                                                         |
| >                 | 大于                                                         |
| ==                | 相等                                                         |
| !=                | 不相等                                                       |
| &&                | 逻辑与                                                       |
|                   |                                                              |
| expr1?expr2:expr3 | 条件（三元）运算符。若表达式 expr1 的计算结果为非零值（算术真），则 执行表达式 expr2，否则执行表达式 expr3。 |

条件三元运算符例子：

```shell
[me@linuxbox~]$ a=0
[me@linuxbox~]$ ((a<1?++a:--a))
[me@linuxbox~]$ echo $a
1
[me@linuxbox~]$ ((a<1?++a:--a))
[me@linuxbox~]$ echo $a
0
```

一个简单的数字表格：

```bash
#!/bin/bash
# arith-loop: script to demonstrate arithmetic operators
finished=0
a=0
printf "a\ta**2\ta**3\n"
printf "=\t====\t====\n"
until ((finished)); do
    b=$((a**2))
    c=$((a**3))
    printf "%d\t%d\t%d\n" $a $b $c
    ((a<10?++a:(finished=1)))
done
```

在这个脚本中，我们基于变量 finished 的值实现了一个 until 循环。首先，把变量 finished 的值设为零（算术假）， 继续执行循环之道它的值变为非零。在循环体内，我们计算计数器 a 的平方和立方。在循环末尾，计算计数器变量 a 的值。 若它小于10（最大迭代次数），则 a 的值加1，否则给变量 finished 赋值为1，使得变量 finished 算术为真， 从而终止循环。运行该脚本得到这样的结果：

```shell
[me@linuxbox ~]$ arith-loop
a    a**2     a**3
=    ====     ====
0    0        0
1    1        1
2    4        8
3    9        27
4    16       64
5    25       125
6    36       216
7    49       343
8    64       512
9    81       729
10   100      1000
```

#### bc - 一种高精度计算器语言

bc可以用于交互，也可以接参数（bc脚本）进行运算，也可以通过标准输入将bc脚本传递给bc程序。

##### 一个脚本实例

```bash
#!/bin/bash
# loan-calc : script to calculate monthly loan payments
PROGNAME=$(basename $0)
usage () {
    cat <<- EOF
    Usage: $PROGNAME PRINCIPAL INTEREST MONTHS
    Where:
    PRINCIPAL is the amount of the loan.
    INTEREST is the APR as a number (7% = 0.07).
    MONTHS is the length of the loan's term.
    EOF
}
if (($# != 3)); then
    usage
    exit 1
fi
principal=$1
interest=$2
months=$3
bc <<- EOF
    scale = 10
    i = $interest / 12
    p = $principal
    n = $months
    a = p * ((i * ((1 + i) ^ n)) / (((1 + i) ^ n) - 1))
    print a, "\n"
EOF
```

当脚本执行后，输出结果像这样：

```shell
[me@linuxbox ~]$ loan-calc 135000 0.0775 180
475
1270.7222490000
```

### 32. 数组

##### 创建一个数组

```shell
[me@linuxbox ~]$ a[1]=foo
[me@linuxbox ~]$ echo ${a[1]}
foo
```

也可以用 declare 命令创建一个数组：

```shell
[me@linuxbox ~]$ declare -a a
```

使用 -a 选项，declare 命令的这个例子创建了数组 a。

##### 数组赋值

```shell
name[subscript]=value
```

或

```shell
name=(value1 value2 ...)
```

value… 是要按照顺序赋给数组的值，从**元素0**开始。

把星期几的英文简写赋值给数组 days，我们可以这样做：

```shell
[me@linuxbox ~]$ days=(Sun Mon Tue Wed Thu Fri Sat)
```

还可以通过指定下标，把值赋给数组中的特定元素：

```shell
[me@linuxbox ~]$ days=([0]=Sun [1]=Mon [2]=Tue [3]=We)
```

##### 访问数组元素

让我们考虑一个简单的数据收集和展示的例子。我们将构建一个脚本，用来检查一个特定目录中文件的修改次数。 从这些数据中，我们的脚本将输出一张表，显示这些文件最后是在一天中的哪个小时被修改的。这样一个脚本 可以被用来确定什么时段一个系统最活跃。这个脚本，称为 hours，输出这样的结果：

```shell
[me@linuxbox ~]$ hours .
Hour Files Hour Files
---- ----- ---- ----
00   0     12   11
01   1     13   7
02   0     14   1
03   0     15   7
04   1     16   6
04   1     17   5
06   6     18   4
07   3     19   4
08   1     20   1
09   14    21   0
10   2     22   0
11   5     23   0
Total files = 80
```

当执行该 hours 程序时，指定当前目录作为目标目录。它打印出一张表显示一天（0-23小时）每小时内， 有多少文件做了最后修改。程序代码如下所示：

```shell
#!/bin/bash
# hours : script to count files by modification time
usage () {
    echo "usage: $(basename $0) directory" >&2
}
# Check that argument is a directory
if [[ ! -d $1 ]]; then
    usage
    exit 1
fi
# Initialize array
for i in {0..23}; do hours[i]=0; done
# Collect data
for i in $(stat -c %y "$1"/* | cut -c 12-13); do
    j=${i/#0}
    ((++hours[j]))
    ((++count))
done
# Display data
echo -e "Hour\tFiles\tHour\tFiles"
echo -e "----\t-----\t----\t-----"
for i in {0..11}; do
    j=$((i + 12))
    printf "%02d\t%d\t%02d\t%d\n" $i ${hours[i]} $j ${hours[j]}
done
printf "\nTotal files = %d\n" $count
```

这个脚本由一个函数（名为 usage），和一个分为四个区块的主体组成。在第一部分，我们检查是否有一个命令行参数， 且该参数为目录。如果不是目录，会显示脚本使用信息并退出。

第二部分初始化一个名为 hours 的数组。给每一个数组元素赋值一个0。虽然没有特殊需要在使用之前准备数组，但是 我们的脚本需要确保没有元素是空值。注意这个循环构建方式很有趣。通过使用花括号展开（{0..23}），我们能 很容易为 for 命令产生一系列的数据（words）。

接下来的一部分收集数据，对目录中的每一个文件运行 stat 程序。我们使用 cut 命令从结果中抽取两位数字的小时字段。 在循环里面，我们需要把小时字段开头的零清除掉，因为 shell 将试图（最终会失败）把从 “00” 到 “09” 的数值解释为八进制（见表35-1）。 下一步，我们以小时为数组索引，来增加其对应的数组元素的值。最后，我们增加一个计数器的值（count），记录目录中总共的文件数目。

脚本的最后一部分显示数组中的内容。我们首先输出两行标题，然后进入一个循环产生两栏输出。最后，输出总共的文件数目。

##### 数组操作

###### 输出整个数组的内容

下标 * 和 @ 可以被用来访问数组中的每一个元素。与位置参数一样，@ 表示法在两者之中更有用处。 这里是一个演示：

```shell
[me@linuxbox ~]$ animals=("a dog" "a cat" "a fish")
[me@linuxbox ~]$ for i in ${animals[*]}; do echo $i; done
a
dog
a
cat
a
fish
[me@linuxbox ~]$ for i in ${animals[@]}; do echo $i; done
a
dog
a
cat
a
fish
[me@linuxbox ~]$ for i in "${animals[*]}"; do echo $i; done
a dog a cat a fish
[me@linuxbox ~]$ for i in "${animals[@]}"; do echo $i; done
a dog
a cat
a fish
```

我们创建了数组 animals，并把三个含有两个字的字符串赋值给数组。然后我们执行四个循环看一下对数组内容进行分词的效果。 表示法 ${animals[*]} 和 ${animals[@]}的行为是一致的直到它们被用引号引起来。

###### 确定数组元素个数

使用参数展开，我们能够确定数组元素的个数，与计算字符串长度的方式几乎相同。这里是一个例子:

```shell
[me@linuxbox ~]$ a[100]=foo
[me@linuxbox ~]$ echo ${#a[@]} # number of array elements
1
[me@linuxbox ~]$ echo ${#a[100]} # length of element 100
3
```

我们创建了数组 a，并把字符串 “foo” 赋值给数组元素100。下一步，我们使用参数展开来检查数组的长度，使用 @ 表示法。 最后，我们查看了包含字符串 “foo” 的数组元素 100 的长度。**有趣的是，尽管我们把字符串赋值给数组元素100， bash 仅仅报告数组中有一个元素。这不同于一些其它语言的行为，数组中未使用的元素（元素0-99）会初始化为空值， 并把它们计入数组长度**。

###### 找到数组使用的下标

因为 bash 允许赋值的数组下标包含 “间隔”，有时候确定哪个元素真正存在是很有用的。为做到这一点， 可以使用以下形式的参数展开：

${!array[*]}

${!array[@]}

这里的 array 是一个数组变量的名字。和其它使用符号 * 和 @ 的展开一样，用引号引起来的 @ 格式是最有用的， 因为它能展开成分离的词。

```shell
[me@linuxbox ~]$ foo=([2]=a [4]=b [6]=c)
[me@linuxbox ~]$ for i in "${foo[@]}"; do echo $i; done
a
b
c
[me@linuxbox ~]$ for i in "${!foo[@]}"; do echo $i; done
2
4
6
```

###### 在数组末尾添加元素

如果我们需要在数组末尾附加数据，那么知道数组中元素的个数是没用的，因为通过 * 和 @ 表示法返回的数值不能 告诉我们使用的最大数组索引。幸运地是，shell 为我们提供了一种解决方案。通过使用 += 赋值运算符， 我们能够自动地把值附加到数组末尾。这里，我们把三个值赋给数组 foo，然后附加另外三个。

```shell
[me@linuxbox~]$ foo=(a b c)
[me@linuxbox~]$ echo ${foo[@]}
a b c
[me@linuxbox~]$ foo+=(d e f)
[me@linuxbox~]$ echo ${foo[@]}
a b c d e f
```

###### 数组排序

就像电子表格，经常有必要对一列数据进行排序。Shell 没有这样做的直接方法，但是通过一点儿代码，并不难实现。

```shell
#!/bin/bash
# array-sort : Sort an array
a=(f e d c b a)
echo "Original array: ${a[@]}"
a_sorted=($(for i in "${a[@]}"; do echo $i; done | sort))
echo "Sorted array: ${a_sorted[@]}"
```

当执行之后，脚本产生这样的结果：

```shell
[me@linuxbox ~]$ array-sort
Original array: f e d c b a
Sorted array:
a b c d e f
```

###### 删除数组

删除一个数组，使用 unset 命令：

```shell
[me@linuxbox ~]$ foo=(a b c d e f)
[me@linuxbox ~]$ echo ${foo[@]}
a b c d e f
[me@linuxbox ~]$ unset foo
[me@linuxbox ~]$ echo ${foo[@]}
[me@linuxbox ~]$
```

也可以使用 unset 命令删除单个的数组元素：

```shell
[me@linuxbox~]$ foo=(a b c d e f)
[me@linuxbox~]$ echo ${foo[@]}
a b c d e f
[me@linuxbox~]$ unset 'foo[2]'
[me@linuxbox~]$ echo ${foo[@]}
a b d e f
```

有趣地是，**给一个数组赋空值不会清空数组内容**：

```shell
[me@linuxbox ~]$ foo=(a b c d e f)
[me@linuxbox ~]$ foo=
[me@linuxbox ~]$ echo ${foo[@]}
b c d e f
```

**任何引用一个不带下标的数组变量，则指的是数组元素0**：

```shell
[me@linuxbox~]$ foo=(a b c d e f)
[me@linuxbox~]$ echo ${foo[@]}
a b c d e f
[me@linuxbox~]$ foo=A
[me@linuxbox~]$ echo ${foo[@]}
A b c d e f
```

###### 关联数组

现在最新的 bash 版本支持关联数组了。关联数组使用字符串而不是整数作为数组索引。 这种功能给出了一种有趣的新方法来管理数据。例如，我们可以创建一个叫做 “colors” 的数组，并用颜色名字作为索引。

```bash
declare -A colors
colors["red"]="#ff0000"
colors["green"]="#00ff00"
colors["blue"]="#0000ff"
```

不同于整数索引的数组，仅仅引用它们就能创建数组，关联数组必须用带有 -A 选项的 declare 命令创建。

访问关联数组元素的方式几乎与整数索引数组相同：

```bash
echo ${colors["blue"]}
```

### 33. 奇珍异宝

